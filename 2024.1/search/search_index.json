{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to NEdit-ng! NEdit-ng is a GUI text editor for programs and plain-text files. NEdit-ng is a Qt port of the Nirvana Editor (NEdit) version 5.6. It is intended to be a drop in replacement for nedit in every practical way, just as on many systems /usr/bin/vi is now a symlink to /usr/bin/vim . Because it is a true port of the original code, it (at least for now) inherits some (but not all) of the limitations of the original. One such limitation is that the text display can only handle 8-bit characters so multi-byte UTF-8 characters appear as multiple glyphs. On the other hand, some aspects have been improved simply by the fact that it is now a Qt application. These help texts are similarly copies of the nedit originals, converted to be viewable in a browser with some text changes, but there are still some sections that haven't been fully updated. The Help menu will also be undergoing some changes to better integrate it with the help texts, in the meantime please pardon our dust!","title":"Welcome"},{"location":"#welcome-to-nedit-ng","text":"NEdit-ng is a GUI text editor for programs and plain-text files. NEdit-ng is a Qt port of the Nirvana Editor (NEdit) version 5.6. It is intended to be a drop in replacement for nedit in every practical way, just as on many systems /usr/bin/vi is now a symlink to /usr/bin/vim . Because it is a true port of the original code, it (at least for now) inherits some (but not all) of the limitations of the original. One such limitation is that the text display can only handle 8-bit characters so multi-byte UTF-8 characters appear as multiple glyphs. On the other hand, some aspects have been improved simply by the fact that it is now a Qt application. These help texts are similarly copies of the nedit originals, converted to be viewable in a browser with some text changes, but there are still some sections that haven't been fully updated. The Help menu will also be undergoing some changes to better integrate it with the help texts, in the meantime please pardon our dust!","title":"Welcome to NEdit-ng!"},{"location":"01/","text":"For new users, the following topics may be of interest: Selecting Text Finding and Replacing Text Cut and Paste Using the Mouse Keyboard Shortcuts Shifting and Filling Programmers should also read: Programming with NEdit-ng If you get into trouble, the Edit \u2192 Undo command can reverse any modifications that you make. NEdit-ng does not change the file you are editing until you tell it to save. Editing an Existing File To open an existing file, choose File \u2192 Open... . Select the file that you want to open in the pop-up dialog that appears and click on Open . You may open any number of files at the same time. Depending on your settings (see Tabbed Editing ) each file can appear in its own editor window, or it can appear under a tab in the same editor window. Using File \u2192 Open... rather than re-typing the NEdit-ng command and running additional copies of NEdit-ng, will give you quick access to all of the files you have open via the Windows menu, and ensure that you don't accidentally open the same file twice. NEdit-ng has no \"main\" window. It remains running as long as at least one editor window is open. Creating a New File If you already have an empty (Untitled) window displayed, just begin typing in the window. To create a new Untitled window, choose File \u2192 New Window or File \u2192 New Tab . To give the file a name and save its contents to the disk, choose File \u2192 Save or File \u2192 Save As... . Backup Files NEdit-ng maintains periodic backups of the file you are editing so that you can recover the file in the event of a problem such as a system crash or network failure. These files are saved under the name ~filename (on Unix), where filename is the name of the file you were editing. If an NEdit-ng process is killed, some of these backup files may remain in your directory. (To remove one of these files on Unix, you may have to prefix the ~ (tilde) character with a \\ (backslash) or with ./ (dot slash) to prevent the shell from interpreting it as a special character.) Shortcuts As you become more familiar with NEdit-ng, substitute the control and function keys shown on the right side of the menus for pulling down menus with the mouse. Dialogs are also streamlined so you can enter information quickly and without using the mouse 1 . To move the keyboard focus around a dialog, use Tab and the arrow keys. The default button a dialog is usually drawn with a highlighted, outline. This button can be activated by pressing Return or Enter . The dialog's Cancel or Close button can be activated by pressing Escape . For example, to replace the string \"thing\" with \"things\" type: Ctrl+R thing Tab things Return 1 Users who have set their keyboard focus mode to \"pointer\" should check Preferences \u2192 Default Settings \u2192 Popups Under Pointer to avoid the additional step of moving the mouse into the dialog.","title":"Getting Started"},{"location":"01/#editing-an-existing-file","text":"To open an existing file, choose File \u2192 Open... . Select the file that you want to open in the pop-up dialog that appears and click on Open . You may open any number of files at the same time. Depending on your settings (see Tabbed Editing ) each file can appear in its own editor window, or it can appear under a tab in the same editor window. Using File \u2192 Open... rather than re-typing the NEdit-ng command and running additional copies of NEdit-ng, will give you quick access to all of the files you have open via the Windows menu, and ensure that you don't accidentally open the same file twice. NEdit-ng has no \"main\" window. It remains running as long as at least one editor window is open.","title":"Editing an Existing File"},{"location":"01/#creating-a-new-file","text":"If you already have an empty (Untitled) window displayed, just begin typing in the window. To create a new Untitled window, choose File \u2192 New Window or File \u2192 New Tab . To give the file a name and save its contents to the disk, choose File \u2192 Save or File \u2192 Save As... .","title":"Creating a New File"},{"location":"01/#backup-files","text":"NEdit-ng maintains periodic backups of the file you are editing so that you can recover the file in the event of a problem such as a system crash or network failure. These files are saved under the name ~filename (on Unix), where filename is the name of the file you were editing. If an NEdit-ng process is killed, some of these backup files may remain in your directory. (To remove one of these files on Unix, you may have to prefix the ~ (tilde) character with a \\ (backslash) or with ./ (dot slash) to prevent the shell from interpreting it as a special character.)","title":"Backup Files"},{"location":"01/#shortcuts","text":"As you become more familiar with NEdit-ng, substitute the control and function keys shown on the right side of the menus for pulling down menus with the mouse. Dialogs are also streamlined so you can enter information quickly and without using the mouse 1 . To move the keyboard focus around a dialog, use Tab and the arrow keys. The default button a dialog is usually drawn with a highlighted, outline. This button can be activated by pressing Return or Enter . The dialog's Cancel or Close button can be activated by pressing Escape . For example, to replace the string \"thing\" with \"things\" type: Ctrl+R thing Tab things Return 1 Users who have set their keyboard focus mode to \"pointer\" should check Preferences \u2192 Default Settings \u2192 Popups Under Pointer to avoid the additional step of moving the mouse into the dialog.","title":"Shortcuts"},{"location":"02/","text":"NEdit-ng has two general types of selections, primary (highlighted text), and secondary (underlined text). Selections can cover either a simple range of text between two points in the file, or they can cover a rectangular area of the file. To select text for copying, deleting, or replacing, press the left mouse button with the pointer at one end of the text you want to select, and drag it to the other end. The text will become highlighted. To select a whole word, double click (click twice quickly in succession). Double clicking and then dragging the mouse will select a number of words. Similarly, you can select a whole line or a number of lines by triple clicking or triple clicking and dragging. Quadruple clicking selects the whole file. After releasing the mouse button, you can still adjust a selection by holding down Shift and dragging on either end of the selection. To delete the selected text, press Delete or Backspace . To replace it, begin typing. To select a rectangle or column of text, hold Ctrl while dragging the mouse. Rectangular selections can be used in any context that normal selections can be used, including cutting and pasting, filling, shifting, dragging, and searching. Operations on rectangular selections automatically fill in tabs and spaces to maintain alignment of text within and to the right of the selection. Note that the interpretation of rectangular selections by Fill Paragraph is slightly different from that of other commands, Shifting and Filling has details. The middle mouse button can be used to make an additional selection (called the secondary selection). As soon as the button is released, the contents of this selection will be copied to the insert position of the window where the mouse was last clicked (the destination window). This position is marked by a caret shaped cursor when the mouse is outside of the destination window. If there is a (primary) selection, adjacent to the cursor in the window, the new text will replace the selected text. Holding Shift while making the secondary selection will move the text, deleting it at the site of the secondary selection, rather than copying it. Selected text can also be dragged to a new location in the file using the middle mouse button. Holding Shift while dragging the text will copy the selected text, leaving the original text in place. Holding Ctrl will drag the text in overlay mode. Normally, dragging moves text by removing it from the selected position at the start of the drag, and inserting it at a new position relative to the mouse. Dragging a block of text over existing characters displaces the characters to the end of the selection. In overlay mode, characters which are occluded by blocks of text being dragged are simply removed. When dragging non-rectangular selections, overlay mode also converts the selection to rectangular form, allowing it to be dragged outside of the bounds of the existing text. Using the Mouse summarizes the mouse commands for making primary and secondary selections. Primary selections can also be made via keyboard commands, see Keyboard Shortcuts .","title":"Selecting Text"},{"location":"03/","text":"The Search menu contains a number of commands for finding and replacing text. Search \u2192 Find... and Search \u2192 Replace... present dialogs for entering text for searching and replacing. These dialogs also allow you to choose whether you want the search to be case sensitive, or whether to use pattern matching syntax (regular expressions). Searches begin at the current text insertion position. Search \u2192 Find Again and Search \u2192 Replace Again repeat the last find or replace command without prompting for search strings. To selectively replace text, use the two commands in combination: Search \u2192 Find Again , then Search \u2192 Replace Again if the highlighted string should be replaced, or Search \u2192 Find Again again to go to the next string. Search \u2192 Find Selection searches for the text contained in the current primary selection (see Selecting Text ). The selected text does not have to be in the current editor window, it may even be in another program. For example, if the word dog appears somewhere in a window on your screen, and you want to find it in the file you are editing, select the word dog by dragging the mouse across it, switch to your NEdit-ng window and choose Search \u2192 Find Selection . Search \u2192 Find Incremental , which opens the interactive search bar, is yet another variation on searching, where every character typed triggers a new search. After you've completed the search string, the next occurrence in the buffer is found by hitting Return , or by clicking on the icon to the left (...). Holding Shift down finds the previous occurrences. A middle click on the clear button copies the content of any existing selection into the search text widget and triggers a new search. Searching Backwards Holding down Shift while choosing any of the search or replace commands from the menu (or using the keyboard shortcut), will search in the reverse direction. Users who have set the search direction using the buttons in the search dialog, may find it a bit confusing that Search \u2192 Find Again and Search \u2192 Replace Again don't continue in the same direction as the original search (for experienced users, consistency of the direction implied by Shift is more important). Selective Replacement To replace only some occurrences of a string within a file, choose Search \u2192 Replace... , enter the string to search for and the string to substitute, and finish by pressing the Find button. When the first occurrence is highlighted, use either Search \u2192 Replace Again ( Ctrl + T ) to replace it, or Search \u2192 Find Again ( Ctrl + G ) to move to the next occurrence without replacing it, and continue in such a manner through all occurrences of interest. To replace all occurrences of a string within some range of text, select the range (see Selecting Text ), choose Search \u2192 Replace... , type the string to search for and the string to substitute, and press the Selection button in the dialog. Note that selecting text inside the search or replace dialog will unselect the text in the window. Replacement in Multiple Documents You can do the same replacement in more than one document at the same time. To do that, enter the search and replacement string in the replacement dialog as usual, then press the Multiple Documents button. NEdit-ng will open another dialog where you can pick which open documents the replacement should take place in. Then press Replace in this dialog to do the replacement. All attributes (Regular Expression, Case Sensitive, etc.) are used as selected in the main dialog.","title":"Finding and Replacing Text"},{"location":"03/#searching-backwards","text":"Holding down Shift while choosing any of the search or replace commands from the menu (or using the keyboard shortcut), will search in the reverse direction. Users who have set the search direction using the buttons in the search dialog, may find it a bit confusing that Search \u2192 Find Again and Search \u2192 Replace Again don't continue in the same direction as the original search (for experienced users, consistency of the direction implied by Shift is more important).","title":"Searching Backwards"},{"location":"03/#selective-replacement","text":"To replace only some occurrences of a string within a file, choose Search \u2192 Replace... , enter the string to search for and the string to substitute, and finish by pressing the Find button. When the first occurrence is highlighted, use either Search \u2192 Replace Again ( Ctrl + T ) to replace it, or Search \u2192 Find Again ( Ctrl + G ) to move to the next occurrence without replacing it, and continue in such a manner through all occurrences of interest. To replace all occurrences of a string within some range of text, select the range (see Selecting Text ), choose Search \u2192 Replace... , type the string to search for and the string to substitute, and press the Selection button in the dialog. Note that selecting text inside the search or replace dialog will unselect the text in the window.","title":"Selective Replacement"},{"location":"03/#replacement-in-multiple-documents","text":"You can do the same replacement in more than one document at the same time. To do that, enter the search and replacement string in the replacement dialog as usual, then press the Multiple Documents button. NEdit-ng will open another dialog where you can pick which open documents the replacement should take place in. Then press Replace in this dialog to do the replacement. All attributes (Regular Expression, Case Sensitive, etc.) are used as selected in the main dialog.","title":"Replacement in Multiple Documents"},{"location":"04/","text":"The easiest way to copy and move text around in your file or between windows is to use the clipboard, a hidden area that temporarily stores text and data. Edit \u2192 Cut removes the selected text (see Selecting Text ) from your file and places it in the clipboard. Once text is in the clipboard, Edit \u2192 Paste will copy it to the insert position in the current window. For example, to move some text from one place to another, select it by dragging the mouse over it, choose Edit \u2192 Cut to remove it, click the pointer to move the insert point where you want the text inserted, then choose Edit \u2192 Paste to insert it. Edit \u2192 Copy copies text to the clipboard without deleting it from your file. You can also use the clipboard to transfer text to and from other programs that support use of the clipboard. There are many other methods for copying and moving text within NEdit-ng windows and between NEdit-ng and other programs. The most common such method is clicking the middle mouse button to copy the primary selection (to the clicked position). Copying the selection by clicking the middle mouse button in many cases is the only way to transfer data to and from some older X programs. Holding Shift while clicking the middle mouse button moves the text, deleting it from its original position, rather than copying it. Other methods for transferring text include secondary selections, primary selection dragging, keyboard-based selection copying, and drag and drop. These are described in detail in: Selecting Text , Using the Mouse , and Keyboard Shortcuts .","title":"Cut and Paste"},{"location":"05/","text":"Mouse-based editing is what NEdit-ng is all about, and learning to use the more advanced features like secondary selections and primary selection dragging will be well worth your while. If you don't have time to learn everything, you can get by adequately with just the left mouse button: Clicking the left button moves the cursor. Dragging with the left button makes a selection. Holding the Shift key while clicking extends the existing selection, or begins a selection between the cursor and the mouse. Double or triple clicking selects a whole word or a whole line. This section will make more sense if you also read Selecting Text , which explains the terminology of selections, that is, what is meant by primary, secondary, rectangular, etc. Button and Modifier Key Summary General meaning of mouse buttons and modifier keys: Buttons Button 1 (left) Cursor position and primary selection Button 2 (middle) Secondary selections, and dragging and copying the primary selection Button 3 (right) Quick-access programmable menu and pan scrolling Modifier keys Shift On primary selections, (left mouse button): Extends selection to the mouse pointer On secondary and copy operations, (middle): Toggles between move and copy Ctrl Makes selection rectangular or insertion columnar Alt (on release) 1 Exchange primary and secondary selections Left Mouse Button The left mouse button is used to position the cursor and to make primary selections. Click Moves the cursor Double Click Selects a whole word Triple Click Selects a whole line Quad Click Selects the whole file Shift Click Adjusts (extends or shrinks) the selection, or if there is no existing selection, begins a new selection between the cursor and the mouse. Ctrl + Shift Click Adjusts (extends or shrinks) the Click selection rectangularly. Drag Selects text between where the mouse was pressed and where it was released. Ctrl Drag Selects rectangle between where the mouse was pressed and where it was released. Right Mouse Button The right mouse button shows a programmable menu for frequently used commands. Click/Drag Pops up the background menu (programmed from Preferences \u2192 Default Settings \u2192 Customize Menus \u2192 Window Background ). Ctrl + Drag Pan scrolling. Scrolls the window both vertically and horizontally, as if you had grabbed it with your mouse. Middle Mouse Button The middle mouse button is for making secondary selections, and copying and dragging the primary selection. Click Copies the primary selection to the clicked position. Shift + Click Moves the primary selection to the clicked position, deleting it from its original position. Drag Outside of the primary selection: Begins a secondary selection. Inside of the primary selection: Moves the selection by dragging. Ctrl + Drag Outside of the primary selection: Begins a rectangular secondary selection. Inside of the primary selection: Drags the selection in overlay mode (see below). When the mouse button is released after creating a secondary selection: No Modifiers If there is a primary selection, replaces it with the secondary selection. Otherwise, inserts the secondary selection at the cursor position. Shift Move the secondary selection, deleting it from its original position. If there is a primary selection, the move will replace the primary selection with the secondary selection. Otherwise, moves the secondary selection to the cursor position. Alt 1 Exchange the primary and secondary selections. While moving the primary selection by dragging with the middle mouse button: Shift Leaves a copy of the original selection in place rather than removing it or blanking the area. Ctrl Changes from insert mode to overlay mode (see below). Escape Cancels drag in progress. Overlay Mode: Normally, dragging moves text by removing it from the selected position at the start of the drag, and inserting it at a new position relative to the mouse. When you drag a block of text over existing characters, the existing characters are displaced to the end of the selection. In overlay mode, characters which are occluded by blocks of text being dragged are simply removed. When dragging non-rectangular selections, overlay mode also converts the selection to rectangular form, allowing it to be dragged outside of the bounds of the existing text. Mouse buttons 4 and 5 are usually represented by a mouse wheel nowadays. They are used to scroll up or down in the text window. 1 Alt may be labeled Meta or Compose-Character on some keyboards. Some window managers may bind combinations of Alt and mouse buttons to window manager operations. In NEdit-ng, Alt is only used on button release, so regardless of the window manager bindings for Alt-modified mouse buttons, you can still do the corresponding NEdit-ng operation by using Alt AFTER the initial mouse press, so that Alt is held while you release the mouse button. If you find this difficult or annoying, you can re-configure most window managers to skip this binding, or re-configure NEdit-ng to use a different key combination.","title":"Using the Mouse"},{"location":"05/#button-and-modifier-key-summary","text":"","title":"Button and Modifier Key Summary"},{"location":"05/#general-meaning-of-mouse-buttons-and-modifier-keys","text":"","title":"General meaning of mouse buttons and modifier keys:"},{"location":"05/#buttons","text":"Button 1 (left) Cursor position and primary selection Button 2 (middle) Secondary selections, and dragging and copying the primary selection Button 3 (right) Quick-access programmable menu and pan scrolling","title":"Buttons"},{"location":"05/#modifier-keys","text":"Shift On primary selections, (left mouse button): Extends selection to the mouse pointer On secondary and copy operations, (middle): Toggles between move and copy Ctrl Makes selection rectangular or insertion columnar Alt (on release) 1 Exchange primary and secondary selections","title":"Modifier keys"},{"location":"05/#left-mouse-button","text":"The left mouse button is used to position the cursor and to make primary selections. Click Moves the cursor Double Click Selects a whole word Triple Click Selects a whole line Quad Click Selects the whole file Shift Click Adjusts (extends or shrinks) the selection, or if there is no existing selection, begins a new selection between the cursor and the mouse. Ctrl + Shift Click Adjusts (extends or shrinks) the Click selection rectangularly. Drag Selects text between where the mouse was pressed and where it was released. Ctrl Drag Selects rectangle between where the mouse was pressed and where it was released.","title":"Left Mouse Button"},{"location":"05/#right-mouse-button","text":"The right mouse button shows a programmable menu for frequently used commands. Click/Drag Pops up the background menu (programmed from Preferences \u2192 Default Settings \u2192 Customize Menus \u2192 Window Background ). Ctrl + Drag Pan scrolling. Scrolls the window both vertically and horizontally, as if you had grabbed it with your mouse.","title":"Right Mouse Button"},{"location":"05/#middle-mouse-button","text":"The middle mouse button is for making secondary selections, and copying and dragging the primary selection. Click Copies the primary selection to the clicked position. Shift + Click Moves the primary selection to the clicked position, deleting it from its original position. Drag Outside of the primary selection: Begins a secondary selection. Inside of the primary selection: Moves the selection by dragging. Ctrl + Drag Outside of the primary selection: Begins a rectangular secondary selection. Inside of the primary selection: Drags the selection in overlay mode (see below). When the mouse button is released after creating a secondary selection: No Modifiers If there is a primary selection, replaces it with the secondary selection. Otherwise, inserts the secondary selection at the cursor position. Shift Move the secondary selection, deleting it from its original position. If there is a primary selection, the move will replace the primary selection with the secondary selection. Otherwise, moves the secondary selection to the cursor position. Alt 1 Exchange the primary and secondary selections. While moving the primary selection by dragging with the middle mouse button: Shift Leaves a copy of the original selection in place rather than removing it or blanking the area. Ctrl Changes from insert mode to overlay mode (see below). Escape Cancels drag in progress. Overlay Mode: Normally, dragging moves text by removing it from the selected position at the start of the drag, and inserting it at a new position relative to the mouse. When you drag a block of text over existing characters, the existing characters are displaced to the end of the selection. In overlay mode, characters which are occluded by blocks of text being dragged are simply removed. When dragging non-rectangular selections, overlay mode also converts the selection to rectangular form, allowing it to be dragged outside of the bounds of the existing text. Mouse buttons 4 and 5 are usually represented by a mouse wheel nowadays. They are used to scroll up or down in the text window. 1 Alt may be labeled Meta or Compose-Character on some keyboards. Some window managers may bind combinations of Alt and mouse buttons to window manager operations. In NEdit-ng, Alt is only used on button release, so regardless of the window manager bindings for Alt-modified mouse buttons, you can still do the corresponding NEdit-ng operation by using Alt AFTER the initial mouse press, so that Alt is held while you release the mouse button. If you find this difficult or annoying, you can re-configure most window managers to skip this binding, or re-configure NEdit-ng to use a different key combination.","title":"Middle Mouse Button"},{"location":"06/","text":"Most of the keyboard shortcuts in NEdit-ng are shown on the right hand sides of menus. However, there are more which are not as obvious. These include; dialog button shortcuts; menu and dialog mnemonics; labeled keyboard keys, such as the arrows, Page Up , Page Down , and Home ; and optional Shift modifiers on accelerator keys, like [Shift] Ctrl + F . Menu Accelerators Pressing the key combinations shown on the right of the menu items is a shortcut for selecting the menu item with the mouse. Some items have the \"Shift\" enclosed in brackets, such as [Shift] Ctrl + F . This indicates that Shift is optional. In Search commands including Shift reverses the direction of the search. In shift commands, it makes the command shift the selected text by a whole tab stop rather than by single characters. Menu Mnemonics Pressing Alt in combination with one of the underlined characters in the menu bar pulls down that menu. Once the menu is pulled down, typing the underlined characters in a menu item (without Alt ) activates that item. With a menu pulled down, you can also use the arrow keys to select menu items, and Space or Enter to activate them. Keyboard Shortcuts within Dialogs The default button in a dialog is usually marked with a highlighted outline. Pressing Return or Enter activates this button. All dialogs have either a Cancel or Close button. This button can be activated by pressing Escape (or Esc ). Pressing Tab moves the keyboard focus to the next item in a dialog. Within an associated group of buttons, the arrow keys move the focus among the buttons. Shift + Tab moves backward through the items. Many items in dialogs have an underline under one character in their name. Pressing Alt along with this character, activates a button as if you had pressed it with the mouse, or moves the keyboard focus to the associated text field or list. You can select items from a list by using the arrow keys to move the selection and space to select. In file selection dialogs, you can type the beginning characters of the file name or directory in the list to select files. Labeled Function Keys The labeled function keys on standard workstation and PC keyboards, like the arrows, and Page Up and Page Down , are active in NEdit-ng, though not shown in the menus. Holding down Ctrl while pressing a named key extends the scope of the action that it performs. For example, Home normally moves the insert cursor the beginning of a line. Ctrl + Home moves it to the beginning of the file. Backspace deletes one character, Ctrl + Backspace deletes one word. Holding down Shift while pressing a named key begins or extends a selection. Combining Shift and Ctrl combines their actions. For example, to select a word without using the mouse, position the cursor at the beginning of the word and press Ctrl + Shift + \u2192 . Holding down Alt modifies selection commands to make the selection rectangular. Your operating system may perform several levels of translation between keyboard keys and the actions they perform in a program. Customizing NEdit-ng , and Config Entries have more information on this subject. Because of all of this configurability, and since keyboards and standards for the meaning of some keys vary from machine to machine, the mappings may be changed from the defaults listed below. Modifier Keys (in general) Ctrl Extends the scope of the action that the key would otherwise perform. For example, Home normally moves the insert cursor to the beginning of a line. Ctrl + Home moves it to the beginning of the file. Backspace deletes one character, Ctrl + Backspace deletes one word. Shift Extends the selection to the cursor position. If there's no selection, begins one between the old and new cursor positions. Alt When modifying a selection, makes the selection rectangular. (For the effects of modifier keys on mouse button presses, see Using the Mouse ) All Keyboards Escape Cancels operation in progress: menu selection, drag, selection, etc. Also equivalent to Cancel or Close button in dialogs. Backspace Delete the character before the cursor Ctrl + Backspace Delete the word before the cursor \u2190 Move the cursor to the left one character Ctrl + \u2190 Move the cursor backward one word (Word delimiters are settable, see Customizing NEdit-ng , and Config Entries ) \u2192 Move the cursor to the right one character Ctrl + \u2192 Move the cursor forward one word \u2191 Move the cursor up one line Ctrl + \u2191 Move the cursor up one paragraph. (Paragraphs are delimited by blank lines) \u2193 Move the cursor down one line. Ctrl + \u2193 Move the cursor down one paragraph. Ctrl + Return Return with automatic indent, regardless of the setting of Auto Indent. Shift + Return Return without automatic indent, regardless of the setting of Auto Indent. Ctrl + Tab Insert an ASCII tab character, without processing emulated tabs. Ctrl + Alt + <C> Insert the control-code equivalent of a key <C> Ctrl + / Select everything (same as Search \u2192 Select All or Ctrl + A ) Ctrl + \\ Unselect Ctrl + U Delete to start of line PC Standard Keyboard Ctrl + Insert Copy the primary selection to the clipboard (same as Edit \u2192 Copy or Ctrl + C ) Ctrl + Shift + Insert Copy the primary selection to the cursor location. Delete Delete the character before the cursor. (Can be configured to delete the character after the cursor, see Customizing NEdit-ng , and Config Entries ) Ctrl + Delete Delete to end of line. Shift + Delete Cut, remove the currently selected text and place it in the clipboard. (same as Edit \u2192 Cut or Ctrl + X ) Ctrl + Shift + Delete Cut the primary selection to the cursor location. Home Move the cursor to the beginning of the line Ctrl + Home Move the cursor to the beginning of the file End Move the cursor to the end of the line Ctrl + End Move the cursor to the end of the file Page Up Scroll and move the cursor up by one page. Page Down Scroll and move the cursor down by one page. Alt Make the menu bar active for keyboard input (Arrow Keys, Return, Escape, and the Space Bar) Alt + Home Switch to the previously active document. Ctrl + Page Up Switch to the previous document. Page Down Switch to the next document. Specialty Keyboards On machines with different styles of keyboards, generally, text editing actions are properly matched to the labeled keys, such as Remove, Next-screen, etc.. If you prefer different key bindings, see Key Binding .","title":"Keyboard Shortcuts"},{"location":"06/#menu-accelerators","text":"Pressing the key combinations shown on the right of the menu items is a shortcut for selecting the menu item with the mouse. Some items have the \"Shift\" enclosed in brackets, such as [Shift] Ctrl + F . This indicates that Shift is optional. In Search commands including Shift reverses the direction of the search. In shift commands, it makes the command shift the selected text by a whole tab stop rather than by single characters.","title":"Menu Accelerators"},{"location":"06/#menu-mnemonics","text":"Pressing Alt in combination with one of the underlined characters in the menu bar pulls down that menu. Once the menu is pulled down, typing the underlined characters in a menu item (without Alt ) activates that item. With a menu pulled down, you can also use the arrow keys to select menu items, and Space or Enter to activate them.","title":"Menu Mnemonics"},{"location":"06/#keyboard-shortcuts-within-dialogs","text":"The default button in a dialog is usually marked with a highlighted outline. Pressing Return or Enter activates this button. All dialogs have either a Cancel or Close button. This button can be activated by pressing Escape (or Esc ). Pressing Tab moves the keyboard focus to the next item in a dialog. Within an associated group of buttons, the arrow keys move the focus among the buttons. Shift + Tab moves backward through the items. Many items in dialogs have an underline under one character in their name. Pressing Alt along with this character, activates a button as if you had pressed it with the mouse, or moves the keyboard focus to the associated text field or list. You can select items from a list by using the arrow keys to move the selection and space to select. In file selection dialogs, you can type the beginning characters of the file name or directory in the list to select files.","title":"Keyboard Shortcuts within Dialogs"},{"location":"06/#labeled-function-keys","text":"The labeled function keys on standard workstation and PC keyboards, like the arrows, and Page Up and Page Down , are active in NEdit-ng, though not shown in the menus. Holding down Ctrl while pressing a named key extends the scope of the action that it performs. For example, Home normally moves the insert cursor the beginning of a line. Ctrl + Home moves it to the beginning of the file. Backspace deletes one character, Ctrl + Backspace deletes one word. Holding down Shift while pressing a named key begins or extends a selection. Combining Shift and Ctrl combines their actions. For example, to select a word without using the mouse, position the cursor at the beginning of the word and press Ctrl + Shift + \u2192 . Holding down Alt modifies selection commands to make the selection rectangular. Your operating system may perform several levels of translation between keyboard keys and the actions they perform in a program. Customizing NEdit-ng , and Config Entries have more information on this subject. Because of all of this configurability, and since keyboards and standards for the meaning of some keys vary from machine to machine, the mappings may be changed from the defaults listed below.","title":"Labeled Function Keys"},{"location":"06/#modifier-keys-in-general","text":"Ctrl Extends the scope of the action that the key would otherwise perform. For example, Home normally moves the insert cursor to the beginning of a line. Ctrl + Home moves it to the beginning of the file. Backspace deletes one character, Ctrl + Backspace deletes one word. Shift Extends the selection to the cursor position. If there's no selection, begins one between the old and new cursor positions. Alt When modifying a selection, makes the selection rectangular. (For the effects of modifier keys on mouse button presses, see Using the Mouse )","title":"Modifier Keys (in general)"},{"location":"06/#all-keyboards","text":"Escape Cancels operation in progress: menu selection, drag, selection, etc. Also equivalent to Cancel or Close button in dialogs. Backspace Delete the character before the cursor Ctrl + Backspace Delete the word before the cursor \u2190 Move the cursor to the left one character Ctrl + \u2190 Move the cursor backward one word (Word delimiters are settable, see Customizing NEdit-ng , and Config Entries ) \u2192 Move the cursor to the right one character Ctrl + \u2192 Move the cursor forward one word \u2191 Move the cursor up one line Ctrl + \u2191 Move the cursor up one paragraph. (Paragraphs are delimited by blank lines) \u2193 Move the cursor down one line. Ctrl + \u2193 Move the cursor down one paragraph. Ctrl + Return Return with automatic indent, regardless of the setting of Auto Indent. Shift + Return Return without automatic indent, regardless of the setting of Auto Indent. Ctrl + Tab Insert an ASCII tab character, without processing emulated tabs. Ctrl + Alt + <C> Insert the control-code equivalent of a key <C> Ctrl + / Select everything (same as Search \u2192 Select All or Ctrl + A ) Ctrl + \\ Unselect Ctrl + U Delete to start of line","title":"All Keyboards"},{"location":"06/#pc-standard-keyboard","text":"Ctrl + Insert Copy the primary selection to the clipboard (same as Edit \u2192 Copy or Ctrl + C ) Ctrl + Shift + Insert Copy the primary selection to the cursor location. Delete Delete the character before the cursor. (Can be configured to delete the character after the cursor, see Customizing NEdit-ng , and Config Entries ) Ctrl + Delete Delete to end of line. Shift + Delete Cut, remove the currently selected text and place it in the clipboard. (same as Edit \u2192 Cut or Ctrl + X ) Ctrl + Shift + Delete Cut the primary selection to the cursor location. Home Move the cursor to the beginning of the line Ctrl + Home Move the cursor to the beginning of the file End Move the cursor to the end of the line Ctrl + End Move the cursor to the end of the file Page Up Scroll and move the cursor up by one page. Page Down Scroll and move the cursor down by one page. Alt Make the menu bar active for keyboard input (Arrow Keys, Return, Escape, and the Space Bar) Alt + Home Switch to the previously active document. Ctrl + Page Up Switch to the previous document. Page Down Switch to the next document.","title":"PC Standard Keyboard"},{"location":"06/#specialty-keyboards","text":"On machines with different styles of keyboards, generally, text editing actions are properly matched to the labeled keys, such as Remove, Next-screen, etc.. If you prefer different key bindings, see Key Binding .","title":"Specialty Keyboards"},{"location":"07/","text":"Shift Left, Shift Right While shifting blocks of text is most important for programmers (See Programming with NEdit-ng ), it is also useful for other tasks, such as creating indented paragraphs. To shift a block of text one character to the right, select the text, then choose Edit \u2192 Shift Right . Note that the accelerator keys for these menu items are Ctrl + 9 and Ctrl + 0 , which correspond to the right and left parenthesis on most US keyboards. Remember them as adjusting the text in the direction pointed to by the parenthesis character. Holding Shift while selecting either Edit \u2192 Shift Left or Edit \u2192 Shift Right will shift the text by one tab stop. If Emulate tabs is enabled in the Preferences \u2192 Tab Stops... dialog, the shift amount is controlled by the Enulated tab spacing setting in that dialog. It is also possible to shift blocks of text by selecting the text rectangularly, and dragging it left or right (and up or down as well). Using a rectangular selection also causes tabs within the selection to be recalculated and substituted, such that the non-whitespace characters remain stationary with respect to the selection. Filling Text filling using the Edit \u2192 Fill Paragraph command is one of the most important concepts in NEdit-ng. And it will be well worth your while to understand how to use it properly. In plain text files, unlike word-processor files, there is no way to tell which lines are continuations of other lines, and which lines are meant to be separate, because there is no distinction in meaning between newline characters which separate lines in a paragraph, and ones which separate paragraphs from other text. This makes it impossible for a text editor like NEdit-ng to tell parts of the text which belong together as a paragraph from carefully arranged individual lines. In continuous wrap mode ( Preferences \u2192 Wrap \u2192 Continuous ), lines automatically wrap and unwrap themselves to line up properly at the right margin. In this mode, you simply omit the newlines within paragraphs and let NEdit-ng make the line breaks as needed. Unfortunately, continuous wrap mode is not appropriate in the majority of situations, because files with extremely long lines are not common under Unix and may not be compatible with all tools, and because you can't achieve effects like indented sections, columns, or program comments, and still take advantage of the automatic wrapping. Without continuous wrapping, paragraph filling is not entirely automatic. Auto Newline wrapping keeps paragraphs lined up as you type, but once entered NEdit-ng can no longer distinguish newlines which join wrapped text, and newlines which must be preserved. Therefore, editing in the middle of a paragraph will often leave the right margin messy and uneven. Since NEdit-ng can't act automatically to keep your text lined up, you need to tell it explicitly where to operate, and that is what Edit \u2192 Fill Paragraph is for. It arranges lines to fill the space between two margins, wrapping the lines neatly at word boundaries. Normally, the left margin for filling is inferred from the text being filled. The first line of each paragraph is considered special, and its left indentation is maintained separately from the remaining lines (for leading indents, bullet points, numbered paragraphs, etc.). Otherwise, the left margin is determined by the furthest left non-whitespace character. The right margin is either the Wrap Margin, set in Preferences \u2192 Wrap \u2192 Wrap Margin... (by default, the right edge of the window), or can also be chosen on the fly by using a rectangular selection (see below). There are three ways to use Fill Paragraph. The simplest is, while you are typing text, and there is no selection, simply select Edit \u2192 Fill Paragraph (or type Ctrl + J ), and NEdit-ng will arrange the text in the paragraph adjacent to the cursor. A paragraph, in this case, means an area of text delimited by blank lines. The second way to use Fill Paragraph is with a selection. If you select a range of text and then choose Edit \u2192 Fill Paragraph , all of the text in the selection will be filled. Again, continuous text between blank lines is interpreted as paragraphs and filled individually, respecting leading indents and blank lines. The third, and most versatile, way to use Fill Paragraph is with a rectangular selection. Fill Paragraph treats rectangular selections differently from other commands. Instead of simply filling the text inside the rectangular selection, NEdit-ng interprets the right edge of the selection as the requested wrap margin. Text to the left of the selection is not disturbed (the usual interpretation of a rectangular selection), but text to the right of the selection is included in the operation and is pulled in to the selected region. This method enables you to fill text to an arbitrary right margin, without going back and forth to the wrap-margin dialog, as well as to exclude text to the left of the selection such as comment bars or other text columns.","title":"Shifting and Filling"},{"location":"07/#shift-left-shift-right","text":"While shifting blocks of text is most important for programmers (See Programming with NEdit-ng ), it is also useful for other tasks, such as creating indented paragraphs. To shift a block of text one character to the right, select the text, then choose Edit \u2192 Shift Right . Note that the accelerator keys for these menu items are Ctrl + 9 and Ctrl + 0 , which correspond to the right and left parenthesis on most US keyboards. Remember them as adjusting the text in the direction pointed to by the parenthesis character. Holding Shift while selecting either Edit \u2192 Shift Left or Edit \u2192 Shift Right will shift the text by one tab stop. If Emulate tabs is enabled in the Preferences \u2192 Tab Stops... dialog, the shift amount is controlled by the Enulated tab spacing setting in that dialog. It is also possible to shift blocks of text by selecting the text rectangularly, and dragging it left or right (and up or down as well). Using a rectangular selection also causes tabs within the selection to be recalculated and substituted, such that the non-whitespace characters remain stationary with respect to the selection.","title":"Shift Left, Shift Right"},{"location":"07/#filling","text":"Text filling using the Edit \u2192 Fill Paragraph command is one of the most important concepts in NEdit-ng. And it will be well worth your while to understand how to use it properly. In plain text files, unlike word-processor files, there is no way to tell which lines are continuations of other lines, and which lines are meant to be separate, because there is no distinction in meaning between newline characters which separate lines in a paragraph, and ones which separate paragraphs from other text. This makes it impossible for a text editor like NEdit-ng to tell parts of the text which belong together as a paragraph from carefully arranged individual lines. In continuous wrap mode ( Preferences \u2192 Wrap \u2192 Continuous ), lines automatically wrap and unwrap themselves to line up properly at the right margin. In this mode, you simply omit the newlines within paragraphs and let NEdit-ng make the line breaks as needed. Unfortunately, continuous wrap mode is not appropriate in the majority of situations, because files with extremely long lines are not common under Unix and may not be compatible with all tools, and because you can't achieve effects like indented sections, columns, or program comments, and still take advantage of the automatic wrapping. Without continuous wrapping, paragraph filling is not entirely automatic. Auto Newline wrapping keeps paragraphs lined up as you type, but once entered NEdit-ng can no longer distinguish newlines which join wrapped text, and newlines which must be preserved. Therefore, editing in the middle of a paragraph will often leave the right margin messy and uneven. Since NEdit-ng can't act automatically to keep your text lined up, you need to tell it explicitly where to operate, and that is what Edit \u2192 Fill Paragraph is for. It arranges lines to fill the space between two margins, wrapping the lines neatly at word boundaries. Normally, the left margin for filling is inferred from the text being filled. The first line of each paragraph is considered special, and its left indentation is maintained separately from the remaining lines (for leading indents, bullet points, numbered paragraphs, etc.). Otherwise, the left margin is determined by the furthest left non-whitespace character. The right margin is either the Wrap Margin, set in Preferences \u2192 Wrap \u2192 Wrap Margin... (by default, the right edge of the window), or can also be chosen on the fly by using a rectangular selection (see below). There are three ways to use Fill Paragraph. The simplest is, while you are typing text, and there is no selection, simply select Edit \u2192 Fill Paragraph (or type Ctrl + J ), and NEdit-ng will arrange the text in the paragraph adjacent to the cursor. A paragraph, in this case, means an area of text delimited by blank lines. The second way to use Fill Paragraph is with a selection. If you select a range of text and then choose Edit \u2192 Fill Paragraph , all of the text in the selection will be filled. Again, continuous text between blank lines is interpreted as paragraphs and filled individually, respecting leading indents and blank lines. The third, and most versatile, way to use Fill Paragraph is with a rectangular selection. Fill Paragraph treats rectangular selections differently from other commands. Instead of simply filling the text inside the rectangular selection, NEdit-ng interprets the right edge of the selection as the requested wrap margin. Text to the left of the selection is not disturbed (the usual interpretation of a rectangular selection), but text to the right of the selection is included in the operation and is pulled in to the selected region. This method enables you to fill text to an arbitrary right margin, without going back and forth to the wrap-margin dialog, as well as to exclude text to the left of the selection such as comment bars or other text columns.","title":"Filling"},{"location":"08/","text":"NEdit-ng is able to display files in distinct editor windows, or to display files under tabs in the same editor window. The Options for controlling the tabbed interface are found under Preferences \u2192 Default Settings \u2192 Tabbed Editing (see also Preferences and NEdit-ng Command Line ). Notice that you can re-group tabs at any time by detaching and attaching them, or moving them, to other windows. This can be done using the Windows menu, or using the context menu which pops up when right clicking on a tab. Within a window you can also drag individual tabs left or right to rearrange their order on the tab bar (unless Preferences \u2192 Default Settings \u2192 Tabbed Editing \u2192 Sort Tabs Alphabetically is checked). You can switch to a tab by simply clicking on it, by selecting it from the Windows menu, or you can use the keyboard. The default key bindings to switch tabs are Ctrl + Page Up / Page Down and Alt + Home , see Keyboard Shortcuts ) but these can be changed.","title":"Tabbed Editing"},{"location":"09/","text":"While plain-text is probably the simplest and most interchangeable file format in the computer world, there is still variation in what plain-text means from system to system. Plain-text files can differ in character encoding, line termination, and wrapping. Character encoding differences are the most obvious and pose the most challenge to portability. NEdit-ng cannot currently display Unicode (UTF-8) text files correctly, nor any multi-byte character set. Some modern programming languages such as JavaScript, Raku and Apple's Swift can accept UTF-8 encoded source code; these should not be written or edited using current versions of NEdit-ng. The primary difference between an MS-DOS format file and a Unix format file is how the lines are terminated. Unix uses a single newline character. MS-DOS uses a carriage-return and a newline. NEdit-ng can read and write both file formats, but internally, it uses the single character Unix standard. NEdit-ng auto-detects MS-DOS format files based on the line termination at the start of the file. Files are judged to be MS-DOS format if all of the first five line terminators, within a maximum range, are MS-DOS style. To change the format in which NEdit-ng writes a file from MS-DOS to Unix or visa versa, use the File \u2192 Save As... command and check or un-check the MS-DOS Format button. Wrapping within text files can vary among individual users, as well as from system to system. Both Windows and macOS make frequent use of plain text files with no implicit right margin. In these files, wrapping is determined by the tool which displays them. Files of this style also exist on Unix systems, despite the fact that they are not supported by all Unix utilities. To display this kind of file properly in NEdit-ng, you have to select the continuous wrap mode ( Preferences \u2192 Wrap \u2192 Continuous ). Wrapping modes are discussed in Preferences and Shifting and Filling . The last and most minute of format differences is the terminating newline. Some programs expect a final terminating newline on all files they read and may fail in various ways on files which do not have it. Some text editors such as Vi enforce the terminating newline on all files that they write; Emacs does not enforce this rule. Users are divided on which is best. NEdit-ng makes the final terminating newline optional ( Preferences \u2192 Default Settings \u2192 Terminate with Line Break on Save ).","title":"File Format"},{"location":"10/","text":"Though general in appearance, NEdit-ng has many features intended specifically for programmers. Major programming-related topics are listed in: Syntax Highlighting , Tab Stops/Emulated Tab Stops , Finding Declarations (ctags) , Calltips , and Auto/Smart Indent . Minor topics related to programming are discussed below. Language Modes When NEdit-ng initially reads a file, it attempts to determine whether the file is in one of the computer languages that it knows about. Knowing what language a file is written in allows NEdit-ng to assign highlight patterns and smart indent macros, and to set language specific preferences like word delimiters, tab emulation, and auto-indent. Language mode can be recognized from both the file name and from the first 200 characters of content. Language mode recognition and language-specific preferences are configured in: Preferences \u2192 Default Settings \u2192 Language Modes... . You can set the language mode manually for a window, by selecting it from Preferences \u2192 Language Mode . Backlighting NEdit-ng can be made to set the background color of particular classes of characters to allow easy identification of those characters. This is particularly useful if you need to be able to distinguish between tabs and spaces in a file where the difference is important. The colors used for backlighting are specified in the config.ini file under nedit.backlightCharTypes . You can turn backlighting on and off through Preferences \u2192 Apply Backlighting . If you prefer to have backlighting turned on for all new windows, use Preferences \u2192 Default Settings \u2192 Apply Backlighting . This setting can be saved along with other preferences using Preferences \u2192 Save Defaults . Line Numbers To find a particular line in a source file by line number, choose Search \u2192 Goto Line Number... . You can also directly select a line number text in a compiler message in your terminal window and choose Search \u2192 Goto Selected . To find out the line number of a particular line in your file, turn on **Preferences \u2192 Statistics Line\" and position the insertion point anywhere on the line. The statistics line continuously updates the line number of the line containing the cursor. To go to a specific column on a given line, choose Search \u2192 Goto Line Number... and enter a line number and a column number separated by a comma. (e.g. Enter 100,12 for line 100 column 12.) If you want to go to a column on the current line just leave out the line number. (e.g. Enter ,45 to go the column 45 on the current line.) Matching Parentheses To help you inspect nested parentheses, brackets, braces, quotes, and other characters, NEdit-ng has both an automatic parenthesis matching mode, and a Goto Matching command. Automatic parenthesis matching is activated when you type, or move the insertion cursor after a parenthesis, bracket, or brace. It momentarily highlights either the opposite character ('Delimiter') or the entire expression ('Range') when the opposite character is visible in the window. To find a matching character anywhere in the file, select it or position the cursor after it, and choose Search \u2192 Goto Matching . If the character matches itself, such as a quote or slash, select the first character of the pair. NEdit-ng will match { , ( , [ , < , \" , ' , ` , / , and \\ . Holding Shift while typing the accelerator key ( Shift + Ctrl + M , by default), will select all of the text between the matching characters. When syntax highlighting is enabled, the matching routines can optionally make use of the syntax information for improved accuracy. In that case, a brace inside a highlighted string will not match a brace inside a comment, for instance. Opening Included Files File \u2192 Open Selected understands the C preprocessor's #include syntax, so selecting an #include line and invoking File \u2192 Open Selected will often find the file referred to, unless doing so depends on the settings of compiler switches or other information not available to NEdit-ng. Interface to Programming Tools Integrated software development environments can be interfaced directly with NEdit-ng via the client server interface. These tools allow you to click directly on compiler and runtime error messages and request NEdit-ng to open files, and select lines of interest. The easiest method is usually to use the tool's interface for character-based editors like vi, to invoke nc-ng, but programmatic interfaces can also be derived using the source code for nc-ng .","title":"Programming with NEdit-ng"},{"location":"10/#language-modes","text":"When NEdit-ng initially reads a file, it attempts to determine whether the file is in one of the computer languages that it knows about. Knowing what language a file is written in allows NEdit-ng to assign highlight patterns and smart indent macros, and to set language specific preferences like word delimiters, tab emulation, and auto-indent. Language mode can be recognized from both the file name and from the first 200 characters of content. Language mode recognition and language-specific preferences are configured in: Preferences \u2192 Default Settings \u2192 Language Modes... . You can set the language mode manually for a window, by selecting it from Preferences \u2192 Language Mode .","title":"Language Modes"},{"location":"10/#backlighting","text":"NEdit-ng can be made to set the background color of particular classes of characters to allow easy identification of those characters. This is particularly useful if you need to be able to distinguish between tabs and spaces in a file where the difference is important. The colors used for backlighting are specified in the config.ini file under nedit.backlightCharTypes . You can turn backlighting on and off through Preferences \u2192 Apply Backlighting . If you prefer to have backlighting turned on for all new windows, use Preferences \u2192 Default Settings \u2192 Apply Backlighting . This setting can be saved along with other preferences using Preferences \u2192 Save Defaults .","title":"Backlighting"},{"location":"10/#line-numbers","text":"To find a particular line in a source file by line number, choose Search \u2192 Goto Line Number... . You can also directly select a line number text in a compiler message in your terminal window and choose Search \u2192 Goto Selected . To find out the line number of a particular line in your file, turn on **Preferences \u2192 Statistics Line\" and position the insertion point anywhere on the line. The statistics line continuously updates the line number of the line containing the cursor. To go to a specific column on a given line, choose Search \u2192 Goto Line Number... and enter a line number and a column number separated by a comma. (e.g. Enter 100,12 for line 100 column 12.) If you want to go to a column on the current line just leave out the line number. (e.g. Enter ,45 to go the column 45 on the current line.)","title":"Line Numbers"},{"location":"10/#matching-parentheses","text":"To help you inspect nested parentheses, brackets, braces, quotes, and other characters, NEdit-ng has both an automatic parenthesis matching mode, and a Goto Matching command. Automatic parenthesis matching is activated when you type, or move the insertion cursor after a parenthesis, bracket, or brace. It momentarily highlights either the opposite character ('Delimiter') or the entire expression ('Range') when the opposite character is visible in the window. To find a matching character anywhere in the file, select it or position the cursor after it, and choose Search \u2192 Goto Matching . If the character matches itself, such as a quote or slash, select the first character of the pair. NEdit-ng will match { , ( , [ , < , \" , ' , ` , / , and \\ . Holding Shift while typing the accelerator key ( Shift + Ctrl + M , by default), will select all of the text between the matching characters. When syntax highlighting is enabled, the matching routines can optionally make use of the syntax information for improved accuracy. In that case, a brace inside a highlighted string will not match a brace inside a comment, for instance.","title":"Matching Parentheses"},{"location":"10/#opening-included-files","text":"File \u2192 Open Selected understands the C preprocessor's #include syntax, so selecting an #include line and invoking File \u2192 Open Selected will often find the file referred to, unless doing so depends on the settings of compiler switches or other information not available to NEdit-ng.","title":"Opening Included Files"},{"location":"10/#interface-to-programming-tools","text":"Integrated software development environments can be interfaced directly with NEdit-ng via the client server interface. These tools allow you to click directly on compiler and runtime error messages and request NEdit-ng to open files, and select lines of interest. The easiest method is usually to use the tool's interface for character-based editors like vi, to invoke nc-ng, but programmatic interfaces can also be derived using the source code for nc-ng .","title":"Interface to Programming Tools"},{"location":"11/","text":"Changing the Tab Stop Distance Tab stops are important for programming in languages which use indentation to show nesting, as short-hand for producing white-space for leading indents. As a programmer, you have to decide how to use indentation, and how or whether tab characters map to your indentation scheme. Ideally, tab characters map directly to the amount of indent that you use to distinguish nesting levels in your code. Unfortunately, the Unix standard for interpretation of tab characters is eight characters (probably dating back to mechanical capabilities of the original teletype), which is usually too coarse for a single indent. Most text editors, NEdit-ng included, allow you to change the interpretation of the tab character, and many programmers take advantage of this, and set their tab stops to 3 or 4 characters to match their programming style. In NEdit-ng you set the hardware tab distance in Preferences \u2192 Tab Stops... for the current window, or Preferences \u2192 Default Settings \u2192 Tab Stops... (general), or Preferences \u2192 Default Settings \u2192 Language Modes... (language-specific) to change the defaults for future windows. The first two menu items bring up the Tabs Dialog window. Changing the meaning of the tab character makes programming much easier while you're in the editor, but can cause you headaches outside of the editor, because there is no way to pass along the tab setting as part of a plain-text file. All of the other tools which display, print, and otherwise process your source code have to be made aware of how the tab stops are set, and must be able to handle the change. Non-standard tab stops can also confuse other programmers, or make editing your code difficult for them if their text editors don't support changes in tab stop distance. Emulated Tab Stops An alternative to changing the interpretation of the tab character is tab stop emulation. In the Tabs Dialog , turning on **Emulated Tabs causes Tab to insert the correct number of spaces and/or tabs to bring the cursor the next emulated tab stop, as if tabs were set at the emulated tab distance rather than the hardware tab distance. Backspacing immediately after entering an emulated tab will delete the fictitious tab as a unit, but as soon as you move the cursor away from the spot, NEdit-ng will forget that the collection of spaces and tabs is a tab, and will treat it as separate characters. To enter a real tab character with \"Emulate Tabs\" turned on, use Ctrl + Tab . It is also possible to tell NEdit-ng not to insert ANY tab characters at all in the course of processing emulated tabs, and in shifting and rectangular insertion/deletion operations, for programmers who worry about the misinterpretation of tab characters on other systems.","title":"Tab Stops/Emulated Tab Stops"},{"location":"11/#changing-the-tab-stop-distance","text":"Tab stops are important for programming in languages which use indentation to show nesting, as short-hand for producing white-space for leading indents. As a programmer, you have to decide how to use indentation, and how or whether tab characters map to your indentation scheme. Ideally, tab characters map directly to the amount of indent that you use to distinguish nesting levels in your code. Unfortunately, the Unix standard for interpretation of tab characters is eight characters (probably dating back to mechanical capabilities of the original teletype), which is usually too coarse for a single indent. Most text editors, NEdit-ng included, allow you to change the interpretation of the tab character, and many programmers take advantage of this, and set their tab stops to 3 or 4 characters to match their programming style. In NEdit-ng you set the hardware tab distance in Preferences \u2192 Tab Stops... for the current window, or Preferences \u2192 Default Settings \u2192 Tab Stops... (general), or Preferences \u2192 Default Settings \u2192 Language Modes... (language-specific) to change the defaults for future windows. The first two menu items bring up the Tabs Dialog window. Changing the meaning of the tab character makes programming much easier while you're in the editor, but can cause you headaches outside of the editor, because there is no way to pass along the tab setting as part of a plain-text file. All of the other tools which display, print, and otherwise process your source code have to be made aware of how the tab stops are set, and must be able to handle the change. Non-standard tab stops can also confuse other programmers, or make editing your code difficult for them if their text editors don't support changes in tab stop distance.","title":"Changing the Tab Stop Distance"},{"location":"11/#emulated-tab-stops","text":"An alternative to changing the interpretation of the tab character is tab stop emulation. In the Tabs Dialog , turning on **Emulated Tabs causes Tab to insert the correct number of spaces and/or tabs to bring the cursor the next emulated tab stop, as if tabs were set at the emulated tab distance rather than the hardware tab distance. Backspacing immediately after entering an emulated tab will delete the fictitious tab as a unit, but as soon as you move the cursor away from the spot, NEdit-ng will forget that the collection of spaces and tabs is a tab, and will treat it as separate characters. To enter a real tab character with \"Emulate Tabs\" turned on, use Ctrl + Tab . It is also possible to tell NEdit-ng not to insert ANY tab characters at all in the course of processing emulated tabs, and in shifting and rectangular insertion/deletion operations, for programmers who worry about the misinterpretation of tab characters on other systems.","title":"Emulated Tab Stops"},{"location":"12/","text":"Programmers who use structured languages usually require some form of automatic indent, so that they don't have to continually re-type the sequences of tabs and/or spaces needed to maintain lengthy running indents. NEdit-ng therefore offers \"smart\" indent, in addition to the traditional automatic indent which simply lines up the cursor position with the previous line. Smart Indent A set of default smart indent macros are available for C and C++, and while these can easily be configured for different default indentation distances, they may not conform to everyone's exact C programming style. Smart indent is programmed in terms of macros in the NEdit-ng macro language which can be entered in: Preferences \u2192 Default Settings \u2192 Indent \u2192 Program Smart Indent . Hooks are provided for intervening at the point that a newline is entered, either via the user pressing the Enter key, or through auto-wrapping; and for arbitrary type-in to act on specific characters typed. To type a newline character without invoking smart-indent when operating in smart-indent mode, hold Shift while pressing the Return or Enter key. Auto-Indent With Indent set to Auto (the default), NEdit-ng keeps a running indent. When you press Return or Enter , spaces and tabs are inserted to line up the insert point under the start of the previous line. Regardless of indent-mode, Ctrl + Return always does the automatic indent; Shift + Return always does a return without indent. Block Indentation Adjustment The Shift Left and Shift Right commands as well as rectangular dragging can be used to adjust the indentation for several lines at once. To shift a block of text one character to the right, select the text, then choose Edit \u2192 Shift Right . Note that the accelerator keys for these menu items are Ctrl + 9 and Ctrl + 0 , which correspond to the right and left parenthesis on most keyboards. Remember them as adjusting the text in the direction pointed to by the parenthesis character. Holding Shift while selecting either Edit \u2192 Shift Left or Edit \u2192 Shift Right will shift the text by one tab stop (or by one emulated tab stop if tab emulation is turned on). Shifting and Filling has details.","title":"Auto/Smart Indent"},{"location":"12/#smart-indent","text":"A set of default smart indent macros are available for C and C++, and while these can easily be configured for different default indentation distances, they may not conform to everyone's exact C programming style. Smart indent is programmed in terms of macros in the NEdit-ng macro language which can be entered in: Preferences \u2192 Default Settings \u2192 Indent \u2192 Program Smart Indent . Hooks are provided for intervening at the point that a newline is entered, either via the user pressing the Enter key, or through auto-wrapping; and for arbitrary type-in to act on specific characters typed. To type a newline character without invoking smart-indent when operating in smart-indent mode, hold Shift while pressing the Return or Enter key.","title":"Smart Indent"},{"location":"12/#auto-indent","text":"With Indent set to Auto (the default), NEdit-ng keeps a running indent. When you press Return or Enter , spaces and tabs are inserted to line up the insert point under the start of the previous line. Regardless of indent-mode, Ctrl + Return always does the automatic indent; Shift + Return always does a return without indent.","title":"Auto-Indent"},{"location":"12/#block-indentation-adjustment","text":"The Shift Left and Shift Right commands as well as rectangular dragging can be used to adjust the indentation for several lines at once. To shift a block of text one character to the right, select the text, then choose Edit \u2192 Shift Right . Note that the accelerator keys for these menu items are Ctrl + 9 and Ctrl + 0 , which correspond to the right and left parenthesis on most keyboards. Remember them as adjusting the text in the direction pointed to by the parenthesis character. Holding Shift while selecting either Edit \u2192 Shift Left or Edit \u2192 Shift Right will shift the text by one tab stop (or by one emulated tab stop if tab emulation is turned on). Shifting and Filling has details.","title":"Block Indentation Adjustment"},{"location":"13/","text":"Syntax Highlighting means using colors and font styles to help distinguish language elements in programming languages and other types of structured files. Programmers use syntax highlighting to understand code faster and better, and to spot many kinds of syntax errors more quickly. To use syntax highlighting in NEdit-ng, select Preferences \u2192 Highlight Syntax . If NEdit-ng recognizes the computer language that you are using, and highlighting rules (patterns) are available for that language, it will highlight your text, and maintain the highlighting, automatically, as you type. If NEdit-ng doesn't correctly recognize the type of the file you are editing, you can manually select a language mode from Preferences \u2192 Language Mode . You can also program the method that NEdit-ng uses to recognize language modes in Preferences \u2192 Default Settings \u2192 Language Modes... . If no highlighting patterns are available for the language that you want to use, you can create new patterns relatively quickly. Highlighting Patterns under Customizing, has details. If you are satisfied with what NEdit-ng is highlighting, but would like it to use different colors or font styles, you can change these by selecting Preferences \u2192 Default Settings \u2192 Syntax Highlighting \u2192 Text Drawing Styles . Highlighting patterns are connected with font and color information through a common set of styles so that colorings defined for one language will be similar across others, and patterns within the same language which are meant to appear identical can be changed in the same place. To understand which styles are used to highlight the language you are interested in, you may need to look at Highlighting Patterns , as well. Syntax highlighting is CPU intensive, and under some circumstances can affect NEdit-ng's responsiveness. If you have a particularly slow system, or work with very large files, you may not want to use it all of the time. Syntax highlighting introduces two kinds of delays. The first is an initial parsing delay, proportional to the size of the file. This delay is also incurred when pasting large sections of text, filtering text through shell commands, and other circumstances involving changes to large amounts of text. The second kind of delay happens when text which has not previously been visible is scrolled in to view. Depending on your system, and the highlight patterns you are using, this may or may not be noticeable. A typing delay is also possible, but unlikely if you are only using the built-in patterns.","title":"Syntax Highlighting"},{"location":"14/","text":"NEdit-ng can process tags files generated using the Unix ctags command or the Exuberant Ctags program. ctags creates index files correlating names of functions and declarations with their locations in C, Fortran, or Pascal source code files. (See the ctags manual page for more information). ctags produces a file called \"tags\" which can be loaded by NEdit-ng. NEdit-ng can manage any number of tags files simultaneously. Tag collisions are handled with a popup menu to let the user decide which tag to use. In 'Smart' mode NEdit-ng will automatically choose the desired tag based on the scope of the file or module. Once loaded, the information in the tags file enables NEdit-ng to go directly to the declaration of a highlighted function or data structure name with a single command. To load a tags file, select File \u2192 Load Tags File... and choose a tags file to load, alternatively, you can specify the name of the tags file on the NEdit-ng command line: nedit-ng -tags tags NEdit-ng can also be set to load a tags file automatically when it starts up. Setting the config.ini item nedit.tagFile to the name of a tag file tells NEdit-ng to look for that file at startup time (see Customizing NEdit-ng ). The file name can be either a complete path name, in which case NEdit-ng will always load the same tags file, or a file name without a path or with a relative path, in which case NEdit-ng will load it starting from the current directory. The second option allows you to have different tags files for different projects, each automatically loaded depending on the directory you're in when you start NEdit-ng. Setting the name to \"tags\" is an obvious choice since this is the name that ctags uses. NEdit-ng normally evaluates relative path tag file specifications every time a file is opened. All accessible tag files are loaded at this time. To disable the automatic loading of tag files specified as relative paths, set the config.ini item nedit.alwaysCheckRelativeTagsSpecs to False . To unload a tags file, select File \u2192 Un-load Tags File... and choose from the list of tags files. NEdit-ng will keep track of tags file updates by checking the timestamp on the files, and automatically update the tags cache. To find the definition of a function or data structure once a tags file is loaded, select the name anywhere it appears in your program (see Selecting Text ) and choose Seardh \u2192 Find Definition .","title":"Finding Declarations (ctags)"},{"location":"15/","text":"Calltips are little yellow boxes that pop up to remind you what the arguments and return type of a function are. More generally, they're a UI mechanism to present a small amount of crucial information in a prominent location. To display a calltip, select some text and choose Search \u2192 Show Calltip . To kill a displayed calltip, hit Esc . Calltips get their information from one of two places -- either a tags file (see Finding Declarations (ctags) ) or a calltips file. First, any loaded calltips files are searched for a definition, and if nothing is found then the tags database is searched. If a tag is found that matches the highlighted text then a calltip is displayed with the first few lines of the definition -- usually enough to show you what the arguments of a function are. You can load a calltips file by using choosing File \u2192 Load Calltips File... . You can unload a calltips file by selecting it from the File \u2192 Unload Calltips File... . You can also choose one or more default calltips files to be loaded for each language mode using the Default calltips file(s) field of the Preferences \u2192 Default Settings \u2192 Language Modes... dialog. The calltips file format is very simple. calltips files are organized in blocks separated by blank lines. The first line of the block is the key, which is the word that is matched when a calltip is requested. The rest of the block is displayed as the calltip. Almost any text at all can appear in a calltip key or a calltip. There are no special characters that need to be escaped. The only issues to note are that trailing whitespace is ignored, and you cannot have a blank line inside a calltip. (Use a single period instead -- it'll be nearly invisible.) You should also avoid calltip keys that begin and end with * characters, since those are used to mark special blocks. There are five special block types \u2014 comment, include, language, alias, and version \u2014 which are distinguished by their first lines: * comment * , * include * , * language * , * alias * , and * version * respectively. Comment blocks are ignored when reading calltips files. Include blocks specify additional calltips files to load, one per line. The ~ character can be used for your $HOME directory, but other shell shortcuts like * and ? can't be used. Include blocks allow you to make a calltips file for your project that includes, say, the calltips files for C++, and Qt. Language blocks specify which language mode the calltips should be used with. When a calltip is requested it won't match tips from languages other than the current language mode. Language blocks only affect the tips listed after the block. Alias blocks allow a calltip to have multiple keys. The first line of the block is the key for the calltip to be displayed, and the rest of the lines are additional keys, one per line, that should also show the calltip. Version blocks are ignored for the time being. You can use calltips in your own macros using the calltip() and kill_calltip() macro subroutines and the $calltip_ID macro variable. See Macro Subroutines for details.","title":"Calltips"},{"location":"16/","text":"Regular expressions (regex's) are useful as a way to match inexact sequences of characters. They can be used in the Search \u2192 Find... and Search \u2192 Replace... dialogs and are at the core of Color Syntax Highlighting patterns. To specify a regular expression in a search dialog, simply click on the Regular Expression radio button in the dialog. A regex is a specification of a pattern to be matched in the searched text. This pattern consists of a sequence of tokens, each being able to match a single character or a sequence of characters in the text, or assert that a specific position within the text has been reached (the latter is called an anchor.) Tokens (also called atoms) can be modified by adding one of a number of special quantifier tokens immediately after the token. A quantifier token specifies how many times the previous token must be matched (see below.) Tokens can be grouped together using one of a number of grouping constructs, the most common being plain parentheses. Tokens that are grouped in this way are also collectively considered to be a regex atom, since this new larger atom may also be modified by a quantifier. A regex can also be organized into a list of alternatives by separating each alternative with pipe characters, | . This is called alternation. A match will be attempted for each alternative listed, in the order specified, until a match results or the list of alternatives is exhausted (see Alternation below.) The 'Any' Character If a dot . appears in a regex, it means to match any character exactly once. By default, dot will not match a newline character, but this behavior can be changed (see Parenthetical Constructs , under the heading, Matching Newlines). Character Classes A character class, or range, matches exactly one character of text, but the candidates for matching are limited to those specified by the class. Classes come in two flavors as described below: [...] Regular class, match only characters listed. [^...] Negated class, match only characters not listed. As with the dot token, by default negated character classes do not match newline, but can be made to do so. The characters that are considered special within a class specification are different than the rest of regex syntax as follows. If the first character in a class is the ] character (second character if the first character is ^ ) it is a literal character and part of the class character set. This also applies if the first or last character is - . Outside of these rules, two characters separated by - form a character range which includes all the characters between the two characters as well. For example, [^f-j] is the same as [^fghij] and means to match any character that is not f , g , h , i , or j . Anchors Anchors are assertions that you are at a very specific position within the search text. NEdit-ng regular expressions support the following anchor tokens: ^ Beginning of line $ End of line < Left word boundary > Right word boundary \\B Not a word boundary Note that the \\B token ensures that neither the left nor the right character are delimiters, or that both left and right characters are delimiters. The left word anchor checks whether the previous character is a delimiter and the next character is not. The right word anchor works in a similar way. Note that word delimiters are user-settable, and defined by the config.ini entry nedit.wordDelimiters , see Config Entries . Quantifiers Quantifiers specify how many times the previous regular expression atom may be matched in the search text. Some quantifiers can produce a large performance penalty, and can in some instances completely lock up NEdit. To prevent this, avoid nested quantifiers, especially those of the maximal matching type (see below.) The following quantifiers are maximal matching, or \"greedy\", in that they match as much text as possible (but don't exclude shorter matches if that is necessary to achieve an overall match). * Match zero or more + Match one or more ? Match zero or one The following quantifiers are minimal matching, or \"lazy\", in that they match as little text as possible (but don't exclude longer matches if that is necessary to achieve an overall match). *? Match zero or more +? Match one or more ?? Match zero or one One final quantifier is the counting quantifier, or brace quantifier. It takes the following basic form: {min,max} Match from min to max times the previous regular expression atom. If min is omitted, it is assumed to be zero. If max is omitted, it is assumed to be infinity. Whether specified or assumed, min must be less than or equal to max . Note that both min and max are limited to 65535. If both are omitted, then the construct is the same as * . Note that {,} and {} are both valid brace constructs. A single number appearing without a comma, e.g. {3} is short for the {min,min} construct, or to match exactly min number of times. The quantifiers {1} and {1,1} are accepted by the syntax, but are optimized away since they mean to match exactly once, which is redundant information. Also, for efficiency, certain combinations of min and max are converted to either * , + , or ? as follows: {} {,} {0,} * {1,} + {,1} {0,1} ? Note that {0} and {0,0} are meaningless and will generate an error message at regular expression compile time. Brace quantifiers can also be \"lazy\". For example {2,5}? would try to match 2 times if possible, and will only match 3, 4, or 5 times if that is what is necessary to achieve an overall match. Alternation A series of alternative patterns to match can be specified by separating them with vertical pipes, | . An example of alternation would be a|be|sea . This will match a , or be , or sea . Each alternative can be an arbitrarily complex regular expression. The alternatives are attempted in the order specified. An empty alternative can be specified if desired, e.g. a|b| . Since an empty alternative can match nothingness (the empty string), this guarantees that the expression will match. Comments Comments are of the form (?#<comment text>) and can be inserted anywhere and have no effect on the execution of the regular expression. They can be handy for documenting very complex regular expressions. Note that a comment begins with (?# and ends at the first occurrence of an ending parenthesis, or the end of the regular expression... period. Comments do not recognize any escape sequences.","title":"Basic Regular Expression Syntax"},{"location":"16/#the-any-character","text":"If a dot . appears in a regex, it means to match any character exactly once. By default, dot will not match a newline character, but this behavior can be changed (see Parenthetical Constructs , under the heading, Matching Newlines).","title":"The 'Any' Character"},{"location":"16/#character-classes","text":"A character class, or range, matches exactly one character of text, but the candidates for matching are limited to those specified by the class. Classes come in two flavors as described below: [...] Regular class, match only characters listed. [^...] Negated class, match only characters not listed. As with the dot token, by default negated character classes do not match newline, but can be made to do so. The characters that are considered special within a class specification are different than the rest of regex syntax as follows. If the first character in a class is the ] character (second character if the first character is ^ ) it is a literal character and part of the class character set. This also applies if the first or last character is - . Outside of these rules, two characters separated by - form a character range which includes all the characters between the two characters as well. For example, [^f-j] is the same as [^fghij] and means to match any character that is not f , g , h , i , or j .","title":"Character Classes"},{"location":"16/#anchors","text":"Anchors are assertions that you are at a very specific position within the search text. NEdit-ng regular expressions support the following anchor tokens: ^ Beginning of line $ End of line < Left word boundary > Right word boundary \\B Not a word boundary Note that the \\B token ensures that neither the left nor the right character are delimiters, or that both left and right characters are delimiters. The left word anchor checks whether the previous character is a delimiter and the next character is not. The right word anchor works in a similar way. Note that word delimiters are user-settable, and defined by the config.ini entry nedit.wordDelimiters , see Config Entries .","title":"Anchors"},{"location":"16/#quantifiers","text":"Quantifiers specify how many times the previous regular expression atom may be matched in the search text. Some quantifiers can produce a large performance penalty, and can in some instances completely lock up NEdit. To prevent this, avoid nested quantifiers, especially those of the maximal matching type (see below.) The following quantifiers are maximal matching, or \"greedy\", in that they match as much text as possible (but don't exclude shorter matches if that is necessary to achieve an overall match). * Match zero or more + Match one or more ? Match zero or one The following quantifiers are minimal matching, or \"lazy\", in that they match as little text as possible (but don't exclude longer matches if that is necessary to achieve an overall match). *? Match zero or more +? Match one or more ?? Match zero or one One final quantifier is the counting quantifier, or brace quantifier. It takes the following basic form: {min,max} Match from min to max times the previous regular expression atom. If min is omitted, it is assumed to be zero. If max is omitted, it is assumed to be infinity. Whether specified or assumed, min must be less than or equal to max . Note that both min and max are limited to 65535. If both are omitted, then the construct is the same as * . Note that {,} and {} are both valid brace constructs. A single number appearing without a comma, e.g. {3} is short for the {min,min} construct, or to match exactly min number of times. The quantifiers {1} and {1,1} are accepted by the syntax, but are optimized away since they mean to match exactly once, which is redundant information. Also, for efficiency, certain combinations of min and max are converted to either * , + , or ? as follows: {} {,} {0,} * {1,} + {,1} {0,1} ? Note that {0} and {0,0} are meaningless and will generate an error message at regular expression compile time. Brace quantifiers can also be \"lazy\". For example {2,5}? would try to match 2 times if possible, and will only match 3, 4, or 5 times if that is what is necessary to achieve an overall match.","title":"Quantifiers"},{"location":"16/#alternation","text":"A series of alternative patterns to match can be specified by separating them with vertical pipes, | . An example of alternation would be a|be|sea . This will match a , or be , or sea . Each alternative can be an arbitrarily complex regular expression. The alternatives are attempted in the order specified. An empty alternative can be specified if desired, e.g. a|b| . Since an empty alternative can match nothingness (the empty string), this guarantees that the expression will match.","title":"Alternation"},{"location":"16/#comments","text":"Comments are of the form (?#<comment text>) and can be inserted anywhere and have no effect on the execution of the regular expression. They can be handy for documenting very complex regular expressions. Note that a comment begins with (?# and ends at the first occurrence of an ending parenthesis, or the end of the regular expression... period. Comments do not recognize any escape sequences.","title":"Comments"},{"location":"17/","text":"Escaping Metacharacters In a regular expression (regex), most ordinary characters match themselves. For example, ab% would match anywhere a followed by b followed by % appeared in the text. Other characters don't match themselves, but are metacharacters. For example, backslash is a special metacharacter which 'escapes' or changes the meaning of the character following it. Thus, to match a literal backslash would require a regular expression to have two backslashes in sequence. NEdit-ng provides the following escape sequences so that metacharacters that are used by the regex syntax can be specified as ordinary characters. \\( \\) \\- \\[ \\] \\< \\> \\{ \\} \\. \\| \\^ \\$ \\* \\+ \\? \\& \\\\ Special Control Characters There are some special characters that are difficult or impossible to type. Many of these characters can be constructed as a sort of metacharacter or sequence by preceding a literal character with a backslash. NEdit-ng recognizes the following special character sequences: \\a alert (bell) \\b backspace \\e ASCII escape character \\f form feed (new page) \\n newline \\r carriage return \\t horizontal tab \\v vertical tab Octal and Hex Escape Sequences Any ASCII character, except NUL , can be specified by using either an octal escape or a hexadecimal escape, each beginning with \\0 or \\x (or \\X ), respectively. For example, \\052 and \\X2A both specify the * character. Escapes for NUL ( \\00 or \\x0 ) are not valid and will generate an error message. Also, any escape that exceeds \\0377 or \\xFF will either cause an error or have any additional character(s) interpreted literally. For example, \\0777 will be interpreted as \\077 (a ? character) followed by 7 since \\0777 is greater than \\0377 . An invalid digit will also end an octal or hexadecimal escape. For example, \\091 will cause an error since 9 is not within an octal escape's range of allowable digits (0-7) and truncation before the 9 yields \\0 which is invalid. Shortcut Escape Sequences NEdit-ng defines some escape sequences that are handy shortcuts for commonly used character classes. Shortcut Class Equivalent to \\d digits [0-9] \\l letters [a-zA-Z] plus locale dependent letters \\s whitespace [ \\t\\r\\v\\f] \\w word characters [\\d\\l_] \\D , \\L , \\S , and \\W are the same as the lowercase versions except that the resulting character class is negated. For example, \\d is equivalent to [0-9] , while \\D is equivalent to [^0-9] . These escape sequences can also be used within a character class. For example, [\\l_] is the same as [a-zA-Z_] , extended with possible locale dependent letters. The escape sequences for special characters, and octal and hexadecimal escapes are also valid within a class. Word Delimiter Tokens Although not strictly a character class, the following escape sequences behave similarly to character classes: \\y Word delimiter character \\Y Not a word delimiter character The \\y token matches any single character that is one of the characters that NEdit-ng recognizes as a word delimiter character, while the \\Y token matches any character that is not a word delimiter character. Word delimiter characters are dynamic in nature, meaning that the user can change them through preference settings. For this reason, they must be handled differently by the regular expression engine. As a consequence of this, \\y and \\Y cannot be used within a character class specification.","title":"Metacharacters"},{"location":"17/#escaping-metacharacters","text":"In a regular expression (regex), most ordinary characters match themselves. For example, ab% would match anywhere a followed by b followed by % appeared in the text. Other characters don't match themselves, but are metacharacters. For example, backslash is a special metacharacter which 'escapes' or changes the meaning of the character following it. Thus, to match a literal backslash would require a regular expression to have two backslashes in sequence. NEdit-ng provides the following escape sequences so that metacharacters that are used by the regex syntax can be specified as ordinary characters. \\( \\) \\- \\[ \\] \\< \\> \\{ \\} \\. \\| \\^ \\$ \\* \\+ \\? \\& \\\\","title":"Escaping Metacharacters"},{"location":"17/#special-control-characters","text":"There are some special characters that are difficult or impossible to type. Many of these characters can be constructed as a sort of metacharacter or sequence by preceding a literal character with a backslash. NEdit-ng recognizes the following special character sequences: \\a alert (bell) \\b backspace \\e ASCII escape character \\f form feed (new page) \\n newline \\r carriage return \\t horizontal tab \\v vertical tab","title":"Special Control Characters"},{"location":"17/#octal-and-hex-escape-sequences","text":"Any ASCII character, except NUL , can be specified by using either an octal escape or a hexadecimal escape, each beginning with \\0 or \\x (or \\X ), respectively. For example, \\052 and \\X2A both specify the * character. Escapes for NUL ( \\00 or \\x0 ) are not valid and will generate an error message. Also, any escape that exceeds \\0377 or \\xFF will either cause an error or have any additional character(s) interpreted literally. For example, \\0777 will be interpreted as \\077 (a ? character) followed by 7 since \\0777 is greater than \\0377 . An invalid digit will also end an octal or hexadecimal escape. For example, \\091 will cause an error since 9 is not within an octal escape's range of allowable digits (0-7) and truncation before the 9 yields \\0 which is invalid.","title":"Octal and Hex Escape Sequences"},{"location":"17/#shortcut-escape-sequences","text":"NEdit-ng defines some escape sequences that are handy shortcuts for commonly used character classes. Shortcut Class Equivalent to \\d digits [0-9] \\l letters [a-zA-Z] plus locale dependent letters \\s whitespace [ \\t\\r\\v\\f] \\w word characters [\\d\\l_] \\D , \\L , \\S , and \\W are the same as the lowercase versions except that the resulting character class is negated. For example, \\d is equivalent to [0-9] , while \\D is equivalent to [^0-9] . These escape sequences can also be used within a character class. For example, [\\l_] is the same as [a-zA-Z_] , extended with possible locale dependent letters. The escape sequences for special characters, and octal and hexadecimal escapes are also valid within a class.","title":"Shortcut Escape Sequences"},{"location":"17/#word-delimiter-tokens","text":"Although not strictly a character class, the following escape sequences behave similarly to character classes: \\y Word delimiter character \\Y Not a word delimiter character The \\y token matches any single character that is one of the characters that NEdit-ng recognizes as a word delimiter character, while the \\Y token matches any character that is not a word delimiter character. Word delimiter characters are dynamic in nature, meaning that the user can change them through preference settings. For this reason, they must be handled differently by the regular expression engine. As a consequence of this, \\y and \\Y cannot be used within a character class specification.","title":"Word Delimiter Tokens"},{"location":"18/","text":"Capturing Parentheses Capturing Parentheses are of the form (<regex>) and can be used to group arbitrarily complex regular expressions. Parentheses can be nested, but the total number of parentheses, nested or otherwise, is limited to 50 pairs. The text that is matched by the regular expression between a matched set of parentheses is captured and available for text substitutions and backreferences (see below.) Capturing parentheses carry a fairly high overhead both in terms of memory used and execution speed, especially if quantified by * or + . Non-Capturing Parentheses Non-Capturing Parentheses are of the form (?:<regex>) and facilitate grouping only and do not incur the overhead of normal capturing parentheses. They should not be counted when determining numbers for capturing parentheses which are used with backreferences and substitutions. Because of the limit on the number of capturing parentheses allowed in a regex, it is advisable to use non-capturing parentheses when possible. Positive Look-Ahead Positive look-ahead constructs are of the form (?=<regex>) and implement a zero width assertion of the enclosed regular expression. In other words, a match of the regular expression contained in the positive look-ahead construct is attempted. If it succeeds, control is passed to the next regular expression atom, but the text that was consumed by the positive look-ahead is first unmatched (backtracked) to the place in the text where the positive look-ahead was first encountered. One application of positive look-ahead is the manual implementation of a first character discrimination optimization. You can include a positive look-ahead that contains a character class which lists every character that the following (potentially complex) regular expression could possibly start with. This will quickly filter out match attempts that cannot possibly succeed. Negative Look-Ahead Negative look-ahead takes the form (?!<regex>) and is exactly the same as positive look-ahead except that the enclosed regular expression must not match. This can be particularly useful when you have an expression that is general, and you want to exclude some special cases. Simply precede the general expression with a negative look-ahead that covers the special cases that need to be filtered out. Positive Look-Behind Positive look-behind constructs are of the form (?<=<regex>) and implement a zero width assertion of the enclosed regular expression in front of the current matching position. It is similar to a positive look-ahead assertion, except for the fact that the match is attempted on the text preceding the current position, possibly even in front of the start of the matching range of the entire regular expression. A restriction on look-behind expressions is the fact that the expression must match a string of a bounded size. In other words, * , + , and {n,} quantifiers are not allowed inside the look-behind expression. Moreover, matching performance is sensitive to the difference between the upper and lower bound on the matching size. The smaller the difference, the better the performance. This is especially important for regular expressions used in highlight patterns. Positive look-behind has similar applications as positive look-ahead. Negative Look-Behind Negative look-behind takes the form (?<!<regex>) and is exactly the same as positive look-behind except that the enclosed regular expression must not match. The same restrictions apply. Note however, that performance is even more sensitive to the distance between the size boundaries: a negative look-behind must not match for any possible size, so the matching engine must check every size. Case Sensitivity There are two parenthetical constructs that control case sensitivity: (?i<regex>) Case insensitive; AbcD and aBCd are equivalent. (?I<regex>) Case sensitive; AbcD and aBCd are different. Regular expressions are case sensitive by default, that is, (?I<regex>) is assumed. All regular expression token types respond appropriately to case insensitivity including character classes and backreferences. There is some extra overhead involved when case insensitivity is in effect, but only to the extent of converting each character compared to lower case. Matching Newlines NEdit-ng regular expressions by default handle the matching of newlines in a way that should seem natural for most editing tasks. There are situations, however, that require finer control over how newlines are matched by some regular expression tokens. By default, NEdit-ng regular expressions will not match a newline character for the following regex tokens: dot . ; a negated character class ( [^...] ); and the following shortcuts for character classes: \\d, \\D, \\l, \\L, \\s, \\S, \\w, \\W, \\Y The matching of newlines can be controlled for the . token, negated character classes, and the \\s and \\S shortcuts by using one of the following parenthetical constructs: (?n<regex>) . , [^...] , \\s , \\S match newlines (?N<regex>) . , [^...] , \\s , \\S don't match newlines (default behavior) Notes on New Parenthetical Constructs Except for plain parentheses, none of the parenthetical constructs capture text. If that is desired, the construct must be wrapped with capturing parentheses, e.g. ((?i<regex>)) . All parenthetical constructs can be nested as deeply as desired, except for capturing parentheses which have a limit of 50 sets of parentheses, regardless of nesting level. Back References Backreferences allow you to match text captured by a set of capturing parenthesis at some later position in your regular expression. A backreference is specified using a single backslash followed by a single digit from 1 to 9 (example: \\3 ). Backreferences have similar syntax to substitutions (see below), but are different from substitutions in that they appear within the regular expression, not the substitution string. The number specified with a backreference identifies which set of text capturing parentheses the backreference is associated with. The text that was most recently captured by these parentheses is used by the backreference to attempt a match. As with substitutions, open parentheses are counted from left to right beginning with 1. So the backreference \\3 will try to match another occurrence of the text most recently matched by the third set of capturing parentheses. As an example, the regular expression (\\d)\\1 could match 22 , 33 , or 00 , but wouldn't match 19 or 01 . A backreference must be associated with a parenthetical expression that is complete. The expression (\\w(\\1)) contains an invalid backreference since the first set of parentheses are not complete at the point where the backreference appears. Substitution Substitution strings are used to replace text matched by a set of capturing parentheses. The substitution string is mostly interpreted as ordinary text except as follows. The escape sequences described above for special characters, and octal and hexadecimal escapes are treated the same way by a substitution string. When the substitution string contains the & character, NEdit-ng will substitute the entire string that was matched by the Search \u2192 Find... ' operation. Any of the first nine sub-expressions of the match string can also be inserted into the replacement string. This is done by inserting a \\ followed by a digit from 1 to 9 that represents the string matched by a parenthesized expression within the regular expression. These expressions are numbered left-to-right in order of their opening parentheses. The capitalization of text inserted by & or \\1 , \\2 , ... \\9 can be altered by preceding them with \\U , \\u , \\L , or \\l . \\u and \\l change only the first character of the inserted entity, while \\U and \\L change the entire entity to upper or lower case, respectively.","title":"Parenthetical Constructs"},{"location":"18/#capturing-parentheses","text":"Capturing Parentheses are of the form (<regex>) and can be used to group arbitrarily complex regular expressions. Parentheses can be nested, but the total number of parentheses, nested or otherwise, is limited to 50 pairs. The text that is matched by the regular expression between a matched set of parentheses is captured and available for text substitutions and backreferences (see below.) Capturing parentheses carry a fairly high overhead both in terms of memory used and execution speed, especially if quantified by * or + .","title":"Capturing Parentheses"},{"location":"18/#non-capturing-parentheses","text":"Non-Capturing Parentheses are of the form (?:<regex>) and facilitate grouping only and do not incur the overhead of normal capturing parentheses. They should not be counted when determining numbers for capturing parentheses which are used with backreferences and substitutions. Because of the limit on the number of capturing parentheses allowed in a regex, it is advisable to use non-capturing parentheses when possible.","title":"Non-Capturing Parentheses"},{"location":"18/#positive-look-ahead","text":"Positive look-ahead constructs are of the form (?=<regex>) and implement a zero width assertion of the enclosed regular expression. In other words, a match of the regular expression contained in the positive look-ahead construct is attempted. If it succeeds, control is passed to the next regular expression atom, but the text that was consumed by the positive look-ahead is first unmatched (backtracked) to the place in the text where the positive look-ahead was first encountered. One application of positive look-ahead is the manual implementation of a first character discrimination optimization. You can include a positive look-ahead that contains a character class which lists every character that the following (potentially complex) regular expression could possibly start with. This will quickly filter out match attempts that cannot possibly succeed.","title":"Positive Look-Ahead"},{"location":"18/#negative-look-ahead","text":"Negative look-ahead takes the form (?!<regex>) and is exactly the same as positive look-ahead except that the enclosed regular expression must not match. This can be particularly useful when you have an expression that is general, and you want to exclude some special cases. Simply precede the general expression with a negative look-ahead that covers the special cases that need to be filtered out.","title":"Negative Look-Ahead"},{"location":"18/#positive-look-behind","text":"Positive look-behind constructs are of the form (?<=<regex>) and implement a zero width assertion of the enclosed regular expression in front of the current matching position. It is similar to a positive look-ahead assertion, except for the fact that the match is attempted on the text preceding the current position, possibly even in front of the start of the matching range of the entire regular expression. A restriction on look-behind expressions is the fact that the expression must match a string of a bounded size. In other words, * , + , and {n,} quantifiers are not allowed inside the look-behind expression. Moreover, matching performance is sensitive to the difference between the upper and lower bound on the matching size. The smaller the difference, the better the performance. This is especially important for regular expressions used in highlight patterns. Positive look-behind has similar applications as positive look-ahead.","title":"Positive Look-Behind"},{"location":"18/#negative-look-behind","text":"Negative look-behind takes the form (?<!<regex>) and is exactly the same as positive look-behind except that the enclosed regular expression must not match. The same restrictions apply. Note however, that performance is even more sensitive to the distance between the size boundaries: a negative look-behind must not match for any possible size, so the matching engine must check every size.","title":"Negative Look-Behind"},{"location":"18/#case-sensitivity","text":"There are two parenthetical constructs that control case sensitivity: (?i<regex>) Case insensitive; AbcD and aBCd are equivalent. (?I<regex>) Case sensitive; AbcD and aBCd are different. Regular expressions are case sensitive by default, that is, (?I<regex>) is assumed. All regular expression token types respond appropriately to case insensitivity including character classes and backreferences. There is some extra overhead involved when case insensitivity is in effect, but only to the extent of converting each character compared to lower case.","title":"Case Sensitivity"},{"location":"18/#matching-newlines","text":"NEdit-ng regular expressions by default handle the matching of newlines in a way that should seem natural for most editing tasks. There are situations, however, that require finer control over how newlines are matched by some regular expression tokens. By default, NEdit-ng regular expressions will not match a newline character for the following regex tokens: dot . ; a negated character class ( [^...] ); and the following shortcuts for character classes: \\d, \\D, \\l, \\L, \\s, \\S, \\w, \\W, \\Y The matching of newlines can be controlled for the . token, negated character classes, and the \\s and \\S shortcuts by using one of the following parenthetical constructs: (?n<regex>) . , [^...] , \\s , \\S match newlines (?N<regex>) . , [^...] , \\s , \\S don't match newlines (default behavior)","title":"Matching Newlines"},{"location":"18/#notes-on-new-parenthetical-constructs","text":"Except for plain parentheses, none of the parenthetical constructs capture text. If that is desired, the construct must be wrapped with capturing parentheses, e.g. ((?i<regex>)) . All parenthetical constructs can be nested as deeply as desired, except for capturing parentheses which have a limit of 50 sets of parentheses, regardless of nesting level.","title":"Notes on New Parenthetical Constructs"},{"location":"18/#back-references","text":"Backreferences allow you to match text captured by a set of capturing parenthesis at some later position in your regular expression. A backreference is specified using a single backslash followed by a single digit from 1 to 9 (example: \\3 ). Backreferences have similar syntax to substitutions (see below), but are different from substitutions in that they appear within the regular expression, not the substitution string. The number specified with a backreference identifies which set of text capturing parentheses the backreference is associated with. The text that was most recently captured by these parentheses is used by the backreference to attempt a match. As with substitutions, open parentheses are counted from left to right beginning with 1. So the backreference \\3 will try to match another occurrence of the text most recently matched by the third set of capturing parentheses. As an example, the regular expression (\\d)\\1 could match 22 , 33 , or 00 , but wouldn't match 19 or 01 . A backreference must be associated with a parenthetical expression that is complete. The expression (\\w(\\1)) contains an invalid backreference since the first set of parentheses are not complete at the point where the backreference appears.","title":"Back References"},{"location":"18/#substitution","text":"Substitution strings are used to replace text matched by a set of capturing parentheses. The substitution string is mostly interpreted as ordinary text except as follows. The escape sequences described above for special characters, and octal and hexadecimal escapes are treated the same way by a substitution string. When the substitution string contains the & character, NEdit-ng will substitute the entire string that was matched by the Search \u2192 Find... ' operation. Any of the first nine sub-expressions of the match string can also be inserted into the replacement string. This is done by inserting a \\ followed by a digit from 1 to 9 that represents the string matched by a parenthesized expression within the regular expression. These expressions are numbered left-to-right in order of their opening parentheses. The capitalization of text inserted by & or \\1 , \\2 , ... \\9 can be altered by preceding them with \\U , \\u , \\L , or \\l . \\u and \\l change only the first character of the inserted entity, while \\U and \\L change the entire entity to upper or lower case, respectively.","title":"Substitution"},{"location":"19/","text":"Substitutions Regular expression substitution can be used to program automatic editing operations. For example, the following are search and replace strings to find occurrences of the 'C' language subroutine get_x , reverse the first and second parameters, add a third parameter of NULL , and change the name to new_get_x : Search string: get_x *\\( *([^ ,]*), *([^\\)]*)\\) Replace string: new_get_x(\\2, \\1, NULL) Ambiguity If a regular expression could match two different parts of the text, it will match the one which begins earliest. If both begin in the same place but match different lengths, or match the same length in different ways, life gets messier, as follows. In general, the possibilities in a list of alternatives are considered in left-to-right order. The possibilities for * , + , and ? are considered longest-first, nested constructs are considered from the outermost in, and concatenated constructs are considered leftmost-first. The match that will be chosen is the one that uses the earliest possibility in the first choice that has to be made. If there is more than one choice, the next will be made in the same manner (earliest possibility) subject to the decision on the first choice. And so forth. For example, (ab|a)b*c could match abc in one of two ways. The first choice is between ab and a ; since ab is earlier, and does lead to a successful overall match, it is chosen. Since the b is already spoken for, the b* must match its last possibility, the empty string, since it must respect the earlier choice. In the particular case where no | s are present and there is only one * , + , or ? , the net effect is that the longest possible match will be chosen. So ab* , presented with xabbbby , will match abbbb . Note that if ab* is tried against xabyabbbz , it will match ab just after x , due to the begins-earliest rule. (In effect, the decision on where to start the match is the first choice to be made, hence subsequent choices must respect it even if this leads them to less-preferred alternatives.) References An excellent book on the care and feeding of regular expressions is Mastering Regular Expressions, 3rd Edition Jeffrey E. F. Friedl August 2006, O'Reilly & Associates ISBN 0-596-52812-4 The first and second editions of this book are still useful for basic introduction to regexes and contain many useful tips and tricks.","title":"Advanced Topics"},{"location":"19/#substitutions","text":"Regular expression substitution can be used to program automatic editing operations. For example, the following are search and replace strings to find occurrences of the 'C' language subroutine get_x , reverse the first and second parameters, add a third parameter of NULL , and change the name to new_get_x : Search string: get_x *\\( *([^ ,]*), *([^\\)]*)\\) Replace string: new_get_x(\\2, \\1, NULL)","title":"Substitutions"},{"location":"19/#ambiguity","text":"If a regular expression could match two different parts of the text, it will match the one which begins earliest. If both begin in the same place but match different lengths, or match the same length in different ways, life gets messier, as follows. In general, the possibilities in a list of alternatives are considered in left-to-right order. The possibilities for * , + , and ? are considered longest-first, nested constructs are considered from the outermost in, and concatenated constructs are considered leftmost-first. The match that will be chosen is the one that uses the earliest possibility in the first choice that has to be made. If there is more than one choice, the next will be made in the same manner (earliest possibility) subject to the decision on the first choice. And so forth. For example, (ab|a)b*c could match abc in one of two ways. The first choice is between ab and a ; since ab is earlier, and does lead to a successful overall match, it is chosen. Since the b is already spoken for, the b* must match its last possibility, the empty string, since it must respect the earlier choice. In the particular case where no | s are present and there is only one * , + , or ? , the net effect is that the longest possible match will be chosen. So ab* , presented with xabbbby , will match abbbb . Note that if ab* is tried against xabyabbbz , it will match ab just after x , due to the begins-earliest rule. (In effect, the decision on where to start the match is the first choice to be made, hence subsequent choices must respect it even if this leads them to less-preferred alternatives.)","title":"Ambiguity"},{"location":"19/#references","text":"An excellent book on the care and feeding of regular expressions is Mastering Regular Expressions, 3rd Edition Jeffrey E. F. Friedl August 2006, O'Reilly & Associates ISBN 0-596-52812-4 The first and second editions of this book are still useful for basic introduction to regexes and contain many useful tips and tricks.","title":"References"},{"location":"20/","text":"The following are regular expression examples which will match: An entire line. ^.*$ Blank lines. ^$ Whitespace on a line. \\s+ Whitespace across lines. (?n\\s+) Whitespace that spans at least two lines. Note minimal matching *? quantifier. (?n\\s*?\\n\\s*) IP address (not robust). (?:\\d{1,3}(?:\\.\\d{1,3}){3}) Two character US Postal state abbreviations (includes territories). [ACDF-IK-PR-W][A-Z] Web addresses. (?:https?://)?www\\.\\S+ Case insensitive double words across line breaks. (?i(?n<(\\S+)\\s+\\1>)) Upper case words with possible punctuation. <[A-Z][^a-z\\s]*>","title":"Example Regular Expressions"},{"location":"21/","text":"The Shell menu allows you to execute shell commands from within NEdit-ng. You can add items to the menu to extend NEdit-ng's command set or to incorporate custom automatic editing features using shell commands or editing languages like awk and sed. To add items to the menu, select Preferences \u2192 Default Settings \u2192 Customize Menus \u2192 Shell Menu . NEdit-ng comes pre-configured with a few useful Unix commands like spell and sort , but we encourage you to add your own custom extensions. Shell \u2192 Filter Selection... prompts you for a shell command to use to process the currently selected text. The output from this command replaces the contents of the selection. Shell \u2192 Execute Command... prompts you for a shell command and replaces the current selection with the output of that command. If there is no selection, it deposits the output at the current insertion point. In the Shell Command field, the % character expands to the name (including directory path), and the # character expands to the current line number of the file in the window. To include a % or # character in the command, use %% or ## , respectively. Shell \u2192 Execute Command Line uses the position of the cursor in the window to indicate a line to execute as a shell command line. The cursor may be positioned anywhere on the line. This command allows you to use an NEdit-ng window as an editable command window for saving output and saving commands for re-execution. Note that the same character expansions described above in Execute Command also occur with this command. The config.ini setting nedit.shell (See Customizing NEdit-ng ) determines which shell is used to execute commands. The default value for this setting is the user's login shell.","title":"Shell Commands and Filters"},{"location":"22/","text":"Selecting Macro \u2192 Learn Keystrokes puts NEdit-ng in learn mode. In learn mode, keystrokes and menu commands are recorded, to be played back later, using Macro \u2192 Replay Keystrokes , or pasted into a macro in the Preferences \u2192 Default Settings \u2192 Customize Menus \u2192 Macro Menu... dialog. Note that only keyboard and menu commands are recorded, not mouse clicks or mouse movements since these have no absolute point of reference, such as cursor or selection position. When you do a mouse-based operation in learn mode, NEdit-ng will beep (repeatedly) to remind you that the operation was not recorded. Learn mode is also the quickest and easiest method for writing macros. The dialog for creating macro commands contains a button labeled Paste Learn / Replay Macro , which will deposit the last sequence learned into the body of the macro. Repeating Actions and Learn/Replay Sequences You can repeat the last (keyboard-based) command, or learn/replay sequence with the Macro \u2192 Repeat... command. To repeat an action, first do the action (that is, insert a character, do a search, move the cursor), then select Macro \u2192 Repeat... , decide how or how many times you want it repeated, and click Ok . For example, to move down 30 lines through a file, you could type: \u2193 Ctrl + , 2 9 Return . To repeat a learn/replay sequence, first learn it, then select Macro \u2192 Repeat... , click on Learn/Replay and how you want it repeated, then click Ok . If the commands you are repeating advance the cursor through the file, you can also repeat them within a range of characters, or from the current cursor position to the end of the file. To iterate over a range of characters, use the primary selection (drag the left mouse button over the text) to mark the range you want to operate on, and select In Selection in the Repeat Macro dialog. When using In Selection or To End with a learned sequence, try to do cursor movement as the last step in the sequence, since testing of the cursor position is only done at the end of the sequence execution. If you do cursor movement first, for example searching for a particular word then doing a modification, the position of the cursor won't be checked until the sequence has potentially gone far beyond the end of your desired range. It's easy for a repeated command to get out of hand, and you can easily generate an infinite loop by using range iteration on a command which doesn't progress. To cancel a repeating command in progress, type Ctrl + . , or select Macro \u2192 Cancel .","title":"Learn/Replay"},{"location":"22/#repeating-actions-and-learnreplay-sequences","text":"You can repeat the last (keyboard-based) command, or learn/replay sequence with the Macro \u2192 Repeat... command. To repeat an action, first do the action (that is, insert a character, do a search, move the cursor), then select Macro \u2192 Repeat... , decide how or how many times you want it repeated, and click Ok . For example, to move down 30 lines through a file, you could type: \u2193 Ctrl + , 2 9 Return . To repeat a learn/replay sequence, first learn it, then select Macro \u2192 Repeat... , click on Learn/Replay and how you want it repeated, then click Ok . If the commands you are repeating advance the cursor through the file, you can also repeat them within a range of characters, or from the current cursor position to the end of the file. To iterate over a range of characters, use the primary selection (drag the left mouse button over the text) to mark the range you want to operate on, and select In Selection in the Repeat Macro dialog. When using In Selection or To End with a learned sequence, try to do cursor movement as the last step in the sequence, since testing of the cursor position is only done at the end of the sequence execution. If you do cursor movement first, for example searching for a particular word then doing a modification, the position of the cursor won't be checked until the sequence has potentially gone far beyond the end of your desired range. It's easy for a repeated command to get out of hand, and you can easily generate an infinite loop by using range iteration on a command which doesn't progress. To cancel a repeating command in progress, type Ctrl + . , or select Macro \u2192 Cancel .","title":"Repeating Actions and Learn/Replay Sequences"},{"location":"23/","text":"Macros can be called from Macro menu commands, the window background menu, within the smart-indent framework, from the autoload macro file (see Preferences ), and from the command line. Macro menu and window background menu commands are defined under Preferences \u2192 Default Settings \u2192 Customize Menus . Help on creating items in these menus can be found in Preferences . NEdit-ng's macro language is a simple interpreter with integer arithmetic, dynamic strings, and C-style looping constructs (very similar to the procedural portion of the Unix awk program). From the macro language, you can call the same action routines which are bound to keyboard keys and menu items, as well additional subroutines for accessing and manipulating editor data, which are specific to the macro language (these are listed in Macro Subroutines , and Action Routines ). Syntax An NEdit-ng macro language program consists of a list of statements, each terminated by a newline. Groups of statements which are executed together conditionally, such as the body of a loop, are surrounded by curly braces {} . Blank lines and comments are also allowed. Comments begin with a # and end with a newline, and can appear either on a line by themselves, or at the end of a statement. Statements which are too long to fit on a single line may be split across several lines, by placing a backslash \\ character at the end of each line to be continued. Data Types The NEdit-ng macro language recognizes only three data types, dynamic character strings, integer values and associative arrays. In general strings and integers can be used interchangeably. If a string represents an integer value, it can be used as an integer. Integers can be compared and concatenated with strings. Arrays may contain integers, strings, or arrays. Arrays are stored key/value pairs. Keys are always stored as strings. Integer Literals Integers are non-fractional numbers in the range of -2147483647 to 2147483647 . In other words, they are 32-bit signed integers. Integer literals must be in decimal. For example: a = -1 b = 1000 Character String Literals Character string literals are enclosed in double quotes. For example: a = \"a string\" dialog(\"Hi there!\", \"OK\") Strings may also include C-language style escape sequences: \\\\ Backslash \\t Tab \\f Form feed \\\" Double quote \\b Backspace \\a Alert \\n Newline \\r Carriage return \\v Vertical tab Also allowed is the escape control character sequence: \\e Escape For example, to send output to the terminal from which NEdit-ng was started, a newline character is necessary because, like printf , t_print requires explicit newlines, and also buffers its output on a per-line basis: t_print(\"a = \" a \"\\n\") Other characters can be expressed as backslash-escape sequences in macro strings. The format is the same as for regular expressions, described in the paragraphs headed \"Octal and Hex Escape Sequences\" in Metacharacters , except that an octal escape sequence can start with any octal digit, not just 0 , so the single character string \"\\0033\" is the same as \"\\33\" , \"\\x1B\" and \"\\e\" . Note that if you want to define a regular expression in a macro string, you need to \"double-up\" the backslashes for the metacharacters with special meaning in regular expressions. For example, the expression (?N(\\s|/\\*(?n(?:(?!\\*/).)*)\\*/|//.*\\n|\\n)+) which matches whitespace or C/C++/Java-style comments, should be written as a macro string as \"(?N(\\\\s|/\\\\*(?n(?:(?!\\\\*/).)*)\\\\*/|//.*\\n|\\n)+)\" (The \\n s towards the end add literal newline characters to the string. The regular expression interpretation treats the newlines as themselves. It can also interpret the sequence \\\\n as a newline, although the macro string here would then contain a literal backslash followed by a lowercase N .) Variables Variable names must begin either with a letter (local variables), or a $ (global variables). Beyond the first character, variables may also contain digits and underscores _ . Variables are called into existence just by setting them (no explicit declarations are necessary). Local variables are limited in scope to the subroutine (or menu item definition) in which they appear. Global variables are accessible from all routines, and their values persist beyond the call which created them, until reset. Built-in Variables NEdit-ng has a number of permanently defined variables, which are used to access global editor information and information about the window in which the macro is executing. These are listed along with the built in functions in Macro Subroutines . Functions and Subroutines The syntax of a function or subroutine call is: function_name(arg1, arg2, ...) where arg1 , arg2 , etc. represent the argument values which are passed to the routine being called. A function or subroutine call can be on a line by itself, as above, or if it returns a value, can be invoked within a character or numeric expression: a = fn1(b, c) + fn2(d) dialog(\"fn3 says: \" fn3()) Arguments are passed by value. This means that you cannot return values via the argument list, only through the function value or indirectly through agreed-upon global variables. Built-in Functions NEdit-ng has a wide range of built in functions which can be called from the macro language. These routines are divided into two classes, macro-language functions, and editor action routines. Editor action routines are more flexible, in that they may be called either from the macro language, or bound directly to keys. They are also limited, however, in that they cannot return values. Macro language routines can return values, but cannot be bound to keys. Nearly all of the built-in subroutines operate on an implied window, which is initially the window from which the macro was started. To manipulate the contents of other windows, use the focus_window subroutine to change the focus to the ones you wish to modify. focus_window can also be used to iterate over all of the currently open windows, using the special keyword names, last and next . NEdit used to support hyphenated action routine names of the form subroutine-name and eventually deprecated support of this. Use of these names was discouraged. NEdit-ng has taken this a step further and has fully dropped support for it in favor of names which use a underscores eg. subroutine_name . User Defined Functions Users can define their own macro subroutines, using the define keyword: define subroutine_name { < body of subroutine > } Subroutine definitions cannot appear within other definitions, nor within macro menu item definitions. They can only appear in (macro) files, such as the autoload macro file (see Preferences ). Macro files can be loaded with File \u2192 Load Macro File... or with the load_macro_file() action. The arguments with which a user-defined subroutine or function was invoked, are presented as $1 , $2 , ... , $9 or $args[<expr>] , where <expr> can be evaluated to an integer from 1 to the number of arguments. The number of arguments can be read from $n_args or $args[] . The array $args[<expr>] is the only way to access arguments beyond the first 9 . To return a value from a subroutine, and/or to exit from the subroutine before the end of the subroutine body, use the return statement: return <value to return> Operators and Expressions Operators have the same meaning and precedence that they do in C, except for ^ , which raises a number to a power ( y^x means y to the x power), rather than bitwise exclusive OR. The table below lists operators in decreasing order of precedence. Operators Associativity () right to left ^ (unary) - ! ++ -- left to right * / % left to right + - left to right > >= < <= == != left to right & left to right \\| left to right && left to right \\|\\| left to right (concatenation) left to right = += -= *= /= %=, &= \\|= right to left The order in which operands are evaluated in an expression is undefined, except for && and || , which like C, evaluate operands left to right, but stop when further evaluation would no longer change the result. Numerical Operators The numeric operators supported by the NEdit-ng macro language are listed below: + addition - subtraction or negation * multiplication / division % modulo ^ power & bitwise and | bitwise or Increment ( ++ ) and decrement ( -- ) operators can also be appended or prepended to variables within an expression. Prepended increment/decrement operators act before the variable is evaluated. Appended increment/decrement operators act after the variable is evaluated. Logical and Comparison Operators Logical operations produce a result of 0 (for false) or 1 (for true). In a logical operation, any non-zero value is recognized to mean true. The logical and comparison operators allowed in the NEdit-ng macro language are listed below: && logical and || logical or ! not > greater < less >= greater or equal <= less or equal == equal (integers and/or strings) != not equal (integers and/or strings) Character String Operators The \"operator\" for concatenating two strings is the absence of an operator. Adjoining character strings or variable names with no operator in between means concatenation: d = a b \"string\" c t_print(\"the value of a is: \" a) Comparison between character strings is done with the == and != operators, (as with integers). There are a number of useful built-in routines for working with character strings, which are listed in Macro Subroutines . Arrays and Array Operators Arrays may contain either strings, integers, or other arrays. Arrays are associative, which means that they relate two pieces of information, the key and the value. The key is always a string; if you use an integer it is converted to a string. To determine if a given key is in an array, use the in keyword. if (\"6\" in x) <body> If the left side of the in keyword is an array, the result is true if every key in the left array is in the right array. Array values are not compared. To iterate through all the keys of an array use the for looping construct. Keys are not guaranteed in any particular order: for (aKey in x) <body> Elements can be removed from an array using the delete command: delete x[3] # deletes element with key 3 delete x[] # deletes all elements The number of elements in an array can be determined by referencing the array with no indices: dialog(\"array x has \" x[] \" elements\", \"OK\") Arrays can be combined with some operators. All the following operators only compare the keys of the arrays. result = x + y (Merge arrays) result is a new array containing keys from both x and y . If duplicates are present values from y are used. result = x - y (Remove keys) result is a new array containing all keys from x that are not in y . result = x & y (Common keys) result is a new array containing all keys which are in both x and y . The values from y are used. result = x | y (Unique keys) result is a new array containing keys which exist in either x or y , but not both. When duplicate keys are encountered using the + and & operators, the values from the array on the right side of the operators are used for the result. All of the above operators are array only, meaning both the left and right sides of the operator must be arrays. The results are also arrays. Array keys can also contain multiple dimensions: x[1, 1, 1] = \"string\" These are used in the expected way, e.g.: for (i = 1; i < 3; i++) { for (j = 1; j < 3; j++) { x[i, j] = k++ } } gives the following array: x[1, 1] = 0 x[1, 2] = 1 x[2, 1] = 2 x[2, 2] = 3 Internally all indices are part of one string, separated by the string $sub_sep (ASCII 0x1c , 'FS'). The first key in the above example is in fact: [\"1\" $sub_sep \"1\"] If you need to extract one of the keys, you can use split() , using $sub_sep as the separator. You can also check for the existence of multi-dimensional array by looking for $sub_sep in the key. Last, you need $sub_sep if you want to use the 'in' keyword. if ((1,2) in myArray) {..} doesn't work, but if ((\"1\" $sub_sep \"2\") in myArray) {..} does work. Looping and Conditionals NEdit-ng supports looping constructs: for and while , and conditional statements: if and else , with essentially the same syntax as C: for (<init>, ...; <condition>; <increment>, ...) <body> while (<condition>) <body> if (<condition>) <body> if (<condition>) <body> else <body> <body> , as in C, can be a single statement, or a list of statements enclosed in curly braces {} . <condition> is an expression which must evaluate to true for the statements in <body> to be executed. for loops may also contain initialization statements, <init> , executed once at the beginning of the loop, and increment/decrement statements (or any arbitrary statement), which are executed at the end of the loop, before the condition is evaluated again. Examples: for (i=0; i<100; i++) j = i * 2 for (i=0, j=20; i<20; i++, j--) { k = i * j t_print(i, j, k) } while (k > 0) { k = k - 1 t_print(k) } for (;;) { if (i-- < 1) break } Loops may contain break and continue statements. A break statement causes an exit from the innermost loop, a continue statement transfers control to the end of the loop.","title":"Macro Language"},{"location":"23/#syntax","text":"An NEdit-ng macro language program consists of a list of statements, each terminated by a newline. Groups of statements which are executed together conditionally, such as the body of a loop, are surrounded by curly braces {} . Blank lines and comments are also allowed. Comments begin with a # and end with a newline, and can appear either on a line by themselves, or at the end of a statement. Statements which are too long to fit on a single line may be split across several lines, by placing a backslash \\ character at the end of each line to be continued.","title":"Syntax"},{"location":"23/#data-types","text":"The NEdit-ng macro language recognizes only three data types, dynamic character strings, integer values and associative arrays. In general strings and integers can be used interchangeably. If a string represents an integer value, it can be used as an integer. Integers can be compared and concatenated with strings. Arrays may contain integers, strings, or arrays. Arrays are stored key/value pairs. Keys are always stored as strings.","title":"Data Types"},{"location":"23/#integer-literals","text":"Integers are non-fractional numbers in the range of -2147483647 to 2147483647 . In other words, they are 32-bit signed integers. Integer literals must be in decimal. For example: a = -1 b = 1000","title":"Integer Literals"},{"location":"23/#character-string-literals","text":"Character string literals are enclosed in double quotes. For example: a = \"a string\" dialog(\"Hi there!\", \"OK\") Strings may also include C-language style escape sequences: \\\\ Backslash \\t Tab \\f Form feed \\\" Double quote \\b Backspace \\a Alert \\n Newline \\r Carriage return \\v Vertical tab Also allowed is the escape control character sequence: \\e Escape For example, to send output to the terminal from which NEdit-ng was started, a newline character is necessary because, like printf , t_print requires explicit newlines, and also buffers its output on a per-line basis: t_print(\"a = \" a \"\\n\") Other characters can be expressed as backslash-escape sequences in macro strings. The format is the same as for regular expressions, described in the paragraphs headed \"Octal and Hex Escape Sequences\" in Metacharacters , except that an octal escape sequence can start with any octal digit, not just 0 , so the single character string \"\\0033\" is the same as \"\\33\" , \"\\x1B\" and \"\\e\" . Note that if you want to define a regular expression in a macro string, you need to \"double-up\" the backslashes for the metacharacters with special meaning in regular expressions. For example, the expression (?N(\\s|/\\*(?n(?:(?!\\*/).)*)\\*/|//.*\\n|\\n)+) which matches whitespace or C/C++/Java-style comments, should be written as a macro string as \"(?N(\\\\s|/\\\\*(?n(?:(?!\\\\*/).)*)\\\\*/|//.*\\n|\\n)+)\" (The \\n s towards the end add literal newline characters to the string. The regular expression interpretation treats the newlines as themselves. It can also interpret the sequence \\\\n as a newline, although the macro string here would then contain a literal backslash followed by a lowercase N .)","title":"Character String Literals"},{"location":"23/#variables","text":"Variable names must begin either with a letter (local variables), or a $ (global variables). Beyond the first character, variables may also contain digits and underscores _ . Variables are called into existence just by setting them (no explicit declarations are necessary). Local variables are limited in scope to the subroutine (or menu item definition) in which they appear. Global variables are accessible from all routines, and their values persist beyond the call which created them, until reset.","title":"Variables"},{"location":"23/#built-in-variables","text":"NEdit-ng has a number of permanently defined variables, which are used to access global editor information and information about the window in which the macro is executing. These are listed along with the built in functions in Macro Subroutines .","title":"Built-in Variables"},{"location":"23/#functions-and-subroutines","text":"The syntax of a function or subroutine call is: function_name(arg1, arg2, ...) where arg1 , arg2 , etc. represent the argument values which are passed to the routine being called. A function or subroutine call can be on a line by itself, as above, or if it returns a value, can be invoked within a character or numeric expression: a = fn1(b, c) + fn2(d) dialog(\"fn3 says: \" fn3()) Arguments are passed by value. This means that you cannot return values via the argument list, only through the function value or indirectly through agreed-upon global variables.","title":"Functions and Subroutines"},{"location":"23/#built-in-functions","text":"NEdit-ng has a wide range of built in functions which can be called from the macro language. These routines are divided into two classes, macro-language functions, and editor action routines. Editor action routines are more flexible, in that they may be called either from the macro language, or bound directly to keys. They are also limited, however, in that they cannot return values. Macro language routines can return values, but cannot be bound to keys. Nearly all of the built-in subroutines operate on an implied window, which is initially the window from which the macro was started. To manipulate the contents of other windows, use the focus_window subroutine to change the focus to the ones you wish to modify. focus_window can also be used to iterate over all of the currently open windows, using the special keyword names, last and next . NEdit used to support hyphenated action routine names of the form subroutine-name and eventually deprecated support of this. Use of these names was discouraged. NEdit-ng has taken this a step further and has fully dropped support for it in favor of names which use a underscores eg. subroutine_name .","title":"Built-in Functions"},{"location":"23/#user-defined-functions","text":"Users can define their own macro subroutines, using the define keyword: define subroutine_name { < body of subroutine > } Subroutine definitions cannot appear within other definitions, nor within macro menu item definitions. They can only appear in (macro) files, such as the autoload macro file (see Preferences ). Macro files can be loaded with File \u2192 Load Macro File... or with the load_macro_file() action. The arguments with which a user-defined subroutine or function was invoked, are presented as $1 , $2 , ... , $9 or $args[<expr>] , where <expr> can be evaluated to an integer from 1 to the number of arguments. The number of arguments can be read from $n_args or $args[] . The array $args[<expr>] is the only way to access arguments beyond the first 9 . To return a value from a subroutine, and/or to exit from the subroutine before the end of the subroutine body, use the return statement: return <value to return>","title":"User Defined Functions"},{"location":"23/#operators-and-expressions","text":"Operators have the same meaning and precedence that they do in C, except for ^ , which raises a number to a power ( y^x means y to the x power), rather than bitwise exclusive OR. The table below lists operators in decreasing order of precedence. Operators Associativity () right to left ^ (unary) - ! ++ -- left to right * / % left to right + - left to right > >= < <= == != left to right & left to right \\| left to right && left to right \\|\\| left to right (concatenation) left to right = += -= *= /= %=, &= \\|= right to left The order in which operands are evaluated in an expression is undefined, except for && and || , which like C, evaluate operands left to right, but stop when further evaluation would no longer change the result.","title":"Operators and Expressions"},{"location":"23/#numerical-operators","text":"The numeric operators supported by the NEdit-ng macro language are listed below: + addition - subtraction or negation * multiplication / division % modulo ^ power & bitwise and | bitwise or Increment ( ++ ) and decrement ( -- ) operators can also be appended or prepended to variables within an expression. Prepended increment/decrement operators act before the variable is evaluated. Appended increment/decrement operators act after the variable is evaluated.","title":"Numerical Operators"},{"location":"23/#logical-and-comparison-operators","text":"Logical operations produce a result of 0 (for false) or 1 (for true). In a logical operation, any non-zero value is recognized to mean true. The logical and comparison operators allowed in the NEdit-ng macro language are listed below: && logical and || logical or ! not > greater < less >= greater or equal <= less or equal == equal (integers and/or strings) != not equal (integers and/or strings)","title":"Logical and Comparison Operators"},{"location":"23/#character-string-operators","text":"The \"operator\" for concatenating two strings is the absence of an operator. Adjoining character strings or variable names with no operator in between means concatenation: d = a b \"string\" c t_print(\"the value of a is: \" a) Comparison between character strings is done with the == and != operators, (as with integers). There are a number of useful built-in routines for working with character strings, which are listed in Macro Subroutines .","title":"Character String Operators"},{"location":"23/#arrays-and-array-operators","text":"Arrays may contain either strings, integers, or other arrays. Arrays are associative, which means that they relate two pieces of information, the key and the value. The key is always a string; if you use an integer it is converted to a string. To determine if a given key is in an array, use the in keyword. if (\"6\" in x) <body> If the left side of the in keyword is an array, the result is true if every key in the left array is in the right array. Array values are not compared. To iterate through all the keys of an array use the for looping construct. Keys are not guaranteed in any particular order: for (aKey in x) <body> Elements can be removed from an array using the delete command: delete x[3] # deletes element with key 3 delete x[] # deletes all elements The number of elements in an array can be determined by referencing the array with no indices: dialog(\"array x has \" x[] \" elements\", \"OK\") Arrays can be combined with some operators. All the following operators only compare the keys of the arrays. result = x + y (Merge arrays) result is a new array containing keys from both x and y . If duplicates are present values from y are used. result = x - y (Remove keys) result is a new array containing all keys from x that are not in y . result = x & y (Common keys) result is a new array containing all keys which are in both x and y . The values from y are used. result = x | y (Unique keys) result is a new array containing keys which exist in either x or y , but not both. When duplicate keys are encountered using the + and & operators, the values from the array on the right side of the operators are used for the result. All of the above operators are array only, meaning both the left and right sides of the operator must be arrays. The results are also arrays. Array keys can also contain multiple dimensions: x[1, 1, 1] = \"string\" These are used in the expected way, e.g.: for (i = 1; i < 3; i++) { for (j = 1; j < 3; j++) { x[i, j] = k++ } } gives the following array: x[1, 1] = 0 x[1, 2] = 1 x[2, 1] = 2 x[2, 2] = 3 Internally all indices are part of one string, separated by the string $sub_sep (ASCII 0x1c , 'FS'). The first key in the above example is in fact: [\"1\" $sub_sep \"1\"] If you need to extract one of the keys, you can use split() , using $sub_sep as the separator. You can also check for the existence of multi-dimensional array by looking for $sub_sep in the key. Last, you need $sub_sep if you want to use the 'in' keyword. if ((1,2) in myArray) {..} doesn't work, but if ((\"1\" $sub_sep \"2\") in myArray) {..} does work.","title":"Arrays and Array Operators"},{"location":"23/#looping-and-conditionals","text":"NEdit-ng supports looping constructs: for and while , and conditional statements: if and else , with essentially the same syntax as C: for (<init>, ...; <condition>; <increment>, ...) <body> while (<condition>) <body> if (<condition>) <body> if (<condition>) <body> else <body> <body> , as in C, can be a single statement, or a list of statements enclosed in curly braces {} . <condition> is an expression which must evaluate to true for the statements in <body> to be executed. for loops may also contain initialization statements, <init> , executed once at the beginning of the loop, and increment/decrement statements (or any arbitrary statement), which are executed at the end of the loop, before the condition is evaluated again. Examples: for (i=0; i<100; i++) j = i * 2 for (i=0, j=20; i<20; i++, j--) { k = i * j t_print(i, j, k) } while (k > 0) { k = k - 1 t_print(k) } for (;;) { if (i-- < 1) break } Loops may contain break and continue statements. A break statement causes an exit from the innermost loop, a continue statement transfers control to the end of the loop.","title":"Looping and Conditionals"},{"location":"24/","text":"Built in Variables These variables are read-only and cannot be changed by direct assignment. $1 , $2 , $3 , $4 , $5 , $6 , $7 , $8 , $9 $args[<expr>] Argument information. The first 9 arguments (if there are that many) can be referenced as read-only values using the shorthand form. All arguments can be accessed as values in the $args array, using a numeric index starting at 1 . The total number of arguments received by a function is given by $n_args or $args[] . $active_pane Index of the current pane. $auto_indent Contains the current preference for auto indent. Can be \"off\" , \"on\" , or \"smart\" . $calltip_ID Equals the ID of the currently displayed calltip, or 0 if no calltip is being displayed. $cursor Position of the cursor in the current window. $column Column number of the cursor position in the current window. $display_width Width of the current pane in pixels. $em_tab_dist If tab stop emulation is turned on in the Preferences \u2192 Tab Stops... dialog, the value is the distance between emulated tab stops. If tab emulation is turned off, the value is 0 . $empty_array An array with no elements. This can be used to initialize an array to an empty state. $file_format Current newline format that the file will be saved with. Can be \"unix\" , \"dos\" or \"macintosh\" . $file_name Name of the file being edited in the current window, stripped of directory component. $file_path Directory component of file being edited in the current window. $font_name Contains the current plain text font name. $highlight_syntax Whether syntax highlighting is turned on. $incremental_backup Contains 1 if incremental auto saving is on, otherwise 0 . $incremental_search_line Has a value of 1 if the preference is selected to always show the incremental search line, otherwise 0 . $language_mode Name of language mode set in the current window. $line Line number of the cursor position in the current window. $locked True if the file has been locked by the user. $make_backup_copy Has a value of 1 if original file is kept in a backup file on save, otherwise 0 . $max_font_width The maximum font width of all the active styles. Syntax highlighting styles are only considered if syntax highlighting is turned on. $min_font_width The minimum font width of all the active styles. Syntax highlighting styles are only considered if syntax highlighting is turned on. $modified True if the file in the current window has been modified and the modifications have not yet been saved. $VERSION Returns NEdit-ng's version number, in the format \"YYYYRRR\" ( \"2019004\" for NEdit-ng 2019.4). $n_display_lines The number of lines visible in the currently active pane. $n_panes The number of panes in the current window. $overtype_mode True if in Overtype mode. $read_only True if the file is read only. $selection_start, $selection_end Beginning and ending positions of the primary selection in the current window, or -1 if there is no text selected in the current window. $selection_left, $selection_right Left and right character offsets of the rectangular (primary) selection in the current window, or -1 if there is no selection or it is not rectangular. $server_name Name of the current NEdit-ng server. $show_line_numbers Whether line numbers are shown next to the text. $show_matching Contains the current preference for showing matching pairs, such as \"[]\" and \"{}\" pairs. Can be \"off\" , \"delimiter\" , or \"range\" . $match_syntax_based Whether pair matching should use syntax information, if available. $statistics_line Has a value of 1 if the statistics line is shown, otherwise 0 . $sub_sep Contains the value of the array sub-script separation string. $tab_dist The distance between tab stops for a hardware tab character, as set in the Preferences \u2192 Tab Stops... dialog. $text_length The length of the text in the current document. $top_line The line number of the top line of the currently active pane. $use_tabs Whether the user is allowing the NEdit-ng to insert tab characters to maintain spacing in tab emulation and rectangular dragging operations. (The setting of the Use tab characters in padding and emulated tabs button in the Preferences \u2192 Tab Stops... dialog.) $wrap_margin The right margin in the current window for text wrapping and filling. $wrap_text The current wrap text mode. Values are \"none\", \"auto\" or \"continuous\". Built-in Subroutines append_file( string, filename ) Appends a string to a named file. Returns 1 on successful write, or 0 if unsuccessful. beep() Ring the bell. calltip( \"text_or_key\" [, pos [, mode or position_modifier, ...]] ) Pops up a calltip. <pos> is an optional position in the buffer where the tip will be displayed. Passing -1 for <pos> is equivalent to not specifying a position, and it guarantees that the tip will appear on-screen somewhere even if the cursor is not. The upper-left corner of the calltip will appear below where the cursor would appear if it were at this position. <mode> is one of \"tipText\" (default), \"tipKey\" , or \"tagKey\" . \"tipText\" displays the text as-is, \"tagKey\" uses it as the key to look up a tag, then converts the tag to a calltip, and \"tipKey\" uses it as the key to look up a calltip, then falls back to \"tagKey\" behavior if that fails. You'll usually use \"tipKey\" or \"tipText\" . Finally, you can modify the placement of the calltip relative to the cursor position (or <pos> ) with one or more of these optional position modifiers: \"center\" aligns the center of the calltip with the position. \"right\" aligns the right edge of the calltip with the position. ( \"center\" and \"right\" may not both be used.) \"above\" places the calltip above the position. \"strict\" does not allow the calltip to move from its position in order to avoid going off-screen or obscuring the cursor. Returns the ID of the calltip if it was found and/or displayed correctly, 0 otherwise. clipboard_to_string() Returns the contents of the clipboard as a macro string. Returns empty string on error. dialog( message, btn_1_label, btn_2_label, ... ) Pop up a dialog for querying and presenting information to the user. First argument is a string to show in the message area of the dialog. Additional optional arguments represent labels for buttons to appear along the bottom of the dialog. Returns the number of the button pressed (the first button is number 1 ), or 0 if the user closed the dialog via the window close box. filename_dialog( [title[, mode[, defaultPath[, filter[, defaultName]]]]] ) Presents a file selection dialog with the given title to the user that prompts for a new or existing file. Options are: <title> will be the title of the dialog, defaults to \"Choose file\". If <mode> is set to \"exist\" (default), the dialog will only allow the user to select files which already exist. If it is set to \"new\" , then, the user may specify any valid filename regardless of a file existing with that name or not. <defaultPath> is the default path to use. Default (or \"\" ) will use the active document's directory. <filter> is the file glob which determines which files to display. Is set to \"*\" if filter is \"\" and by default. <defaultName> is the default filename that is filled in automatically. Returns \"\" if the user cancelled the dialog, otherwise returns the fully-qualified path, including the filename. focus_window( window_name ) Sets the window on which subsequent macro commands operate. <window_name> can be either a fully qualified file name, or a relative filename (which will be completed from NEdit-ng's working directory) or one of \"last\" for the last window created, or \"next\" for the next window in the chain from the currently focused window (the first window being the one returned from calling focus_window(\"last\") . Returns the name of the newly-focused window, or an empty string if the requested window was not found. get_character( position ) Returns the single character at the position indicated by the first argument to the routine from the current window. get_range( start, end ) Returns the text between a starting and ending position from the current window. get_selection() Returns a string containing the text currently selected by the primary selection either from the current window (no keyword), or from anywhere on the screen (keyword \"any\"). getenv( name ) Gets the value of an environment variable. kill_calltip( [calltip_ID] ) Kills any calltip that is being displayed in the window in which the macro is running. If there is no displayed calltip this does nothing. If a calltip ID is supplied then the calltip is killed only if its ID is <calltip_ID> . length( string ) Returns the length of a string list_dialog( message, text, btn_1_label, btn_2_label, ... ) Pop up a dialog for prompting the user to choose a line from the given text string. The first argument is a message string to be used as a title for the fixed text describing the list. The second string provides the list data: this is a text string in which list entries are separated by newline characters. Additional optional arguments represent labels for buttons to appear along the bottom of the dialog. Returns the line of text selected by the user as the function value (without any newline separator) or the empty string if none was selected, and number of the button pressed (the first button is number 1 ), in $list_dialog_button . If the user closes the dialog via the window close box, the function returns the empty string, and $list_dialog_button returns 0 . max( n1, n2, ... ) Returns the maximum value of all of its arguments min( n1, n2, ... ) Returns the minimum value of all of its arguments read_file( filename ) Reads the contents of a text file into a string. On success, returns 1 in $read_status , and the contents of the file as a string in the subroutine return value. On failure, returns the empty string \"\" and a 0 $read_status . replace_in_string( string, search_for, replace_with [, type, \"copy\"] ) Replaces all occurrences of a search string in a string with a replacement string. Arguments are 1: string to search in, 2: string to search for, 3: replacement string. There are two optional arguments. One is a search type, either \"literal\" , \"case\" , \"word\" , \"caseWord\" , \"regex\" , or \"regexNoCase\" . The default search type is \"literal\" . If the optional \"copy\" argument is specified, a copy of the input string is returned when no replacements were performed. By default an empty string ( \"\" ) will be returned in this case. Returns a new string with all of the replacements done. replace_range( start, end, string ) Replaces all the text between two positions in the current window. If the cursor position is between start and end it will be set to start. replace_selection( string ) Replaces the primary-selection selected text in the current window. replace_substring( string, start, end, replace_with ) Replacing a substring between two positions in a string within another string. revert_to_saved() Reloads the file, discarding all changes done to the document by the user since the last save. search( search_for, start [, search_type, wrap, direction] ) Searches silently in a window without dialogs, beeps, or changes to the selection. Arguments are: 1: string to search for, 2: starting position. Optional arguments may include the strings: \"wrap\" to make the search wrap around the beginning or end of the string, \"backward\" or \"forward\" to change the search direction ( \"forward\" is the default), \"literal\" , \"case\" , \"word\" , \"caseWord\" , \"regex\" , or \"regexNoCase\" to change the search type (default is \"literal\" ). Returns the starting position of the match, or -1 if nothing matched. Also returns the ending position of the match in $search_end . search_string( string, search_for, start [, search_type, direction] ) Built-in macro subroutine for searching a string. Arguments are 1: string to search in, 2: string to search for, 3: starting position. Optional arguments may include the strings: \"wrap\" to make the search wrap around the beginning or end of the string, \"backward\" or \"forward\" to change the search direction ( \"forward\" is the default), \"literal\" , \"case\" , \"word\" , \"caseWord\" , \"regex\" , or \"regexNoCase\" to change the search type (default is \"literal\" ). Returns the starting position of the match, or -1 if nothing matched. Also returns the ending position of the match in $search_end . select( start, end ) Selects (with the primary selection) text in the current buffer between a starting and ending position. select_rectangle( start, end, left, right ) Selects a rectangular area of text between a starting and ending position, and confined horizontally to characters displayed between positions \"left\" , and \"right\" . set_cursor_pos( position ) Set the cursor position for the current window. shell_command( command, input_string ) Executes a shell command, feeding it input from input_string . On completion, output from the command is returned as the function value, and the command's exit status is returned in the global variable $shell_cmd_status . split(string, separation_string [, search_type]) Splits a string using the separator specified. Optionally the <search_type> argument can specify how the <separation_string> is interpreted. The default is \"literal\" . The returned value is an array with keys beginning at 0 . string_dialog( message, btn_1_label, btn_2_label, ... ) Pops up a dialog prompting the user to enter information. The first argument is a string to show in the message area of the dialog. Additional optional arguments represent labels for buttons to appear along the bottom of the dialog. Returns the string entered by the user as the function value, and number of the button pressed (the first button is number 1 ), in $string_dialog_button . If the user closes the dialog via the window close box, the function returns the empty string, and $string_dialog_button returns 0 . string_compare(string1, string2 [, consider-case]) Compare two strings and return 0 if they are equal, -1 if string1 is lexicographically less than string2 or 1 if string1 is lexicographically greater than string2. The values for the optional consider-case argument is either \"case\" or \"nocase\" . The default is to do a case sensitive comparison. string_to_clipboard( string ) Copy the contents of a macro string to the clipboard. substring( string, start [, end] ) Returns the portion of a string between a start and end position (with the position of the beginning of the string being 0 ). If end is missing, the position of the end of the string is used. If either of the positions are negative, they are treated as relative to the end of the string. A position specified either before the start of the string or after the end of the string is repositioned to the nearest valid string position. If the start position is beyond the end position, the empty string is returned. t_print( string1, string2, ... ) Writes strings to the terminal (stdout) from which NEdit-ng was started. tolower( string ) Return an all lower-case version of string . toupper( string ) Return an all upper-case version of string . valid_number( string ) Returns 1 if the string can be converted to a number without error following the same rules that the implicit conversion would. Otherwise 0 . write_file( string, filename ) Writes a string (parameter 1) to a file named in parameter 2. Returns 1 on successful write, or 0 if unsuccessful. Deprecated Functions Some functions are included only for supporting legacy macros. You should not use any of these functions in any new macro you write. match() DEPRECATED Use select_to_matching() instead. Deprecated Built in Variables Some global variables no longer have a practical meaning in NEdit-ng. You should not use any of these variables in any new macro you write. $font_name_bold Contains the current bold text font name. DEPRECATED NEdit has dropped support for simultanious different fonts, use $font_name $font_name_bold_italic Contains the current bold-italic text font name. DEPRECATED NEdit has dropped support for simultanious different fonts, use $font_name $font_name_italic Contains the current italic text font name. DEPRECATED NEdit has dropped support for simultanious different fonts, use $font_name","title":"Macro Subroutines"},{"location":"24/#built-in-variables","text":"These variables are read-only and cannot be changed by direct assignment. $1 , $2 , $3 , $4 , $5 , $6 , $7 , $8 , $9 $args[<expr>] Argument information. The first 9 arguments (if there are that many) can be referenced as read-only values using the shorthand form. All arguments can be accessed as values in the $args array, using a numeric index starting at 1 . The total number of arguments received by a function is given by $n_args or $args[] . $active_pane Index of the current pane. $auto_indent Contains the current preference for auto indent. Can be \"off\" , \"on\" , or \"smart\" . $calltip_ID Equals the ID of the currently displayed calltip, or 0 if no calltip is being displayed. $cursor Position of the cursor in the current window. $column Column number of the cursor position in the current window. $display_width Width of the current pane in pixels. $em_tab_dist If tab stop emulation is turned on in the Preferences \u2192 Tab Stops... dialog, the value is the distance between emulated tab stops. If tab emulation is turned off, the value is 0 . $empty_array An array with no elements. This can be used to initialize an array to an empty state. $file_format Current newline format that the file will be saved with. Can be \"unix\" , \"dos\" or \"macintosh\" . $file_name Name of the file being edited in the current window, stripped of directory component. $file_path Directory component of file being edited in the current window. $font_name Contains the current plain text font name. $highlight_syntax Whether syntax highlighting is turned on. $incremental_backup Contains 1 if incremental auto saving is on, otherwise 0 . $incremental_search_line Has a value of 1 if the preference is selected to always show the incremental search line, otherwise 0 . $language_mode Name of language mode set in the current window. $line Line number of the cursor position in the current window. $locked True if the file has been locked by the user. $make_backup_copy Has a value of 1 if original file is kept in a backup file on save, otherwise 0 . $max_font_width The maximum font width of all the active styles. Syntax highlighting styles are only considered if syntax highlighting is turned on. $min_font_width The minimum font width of all the active styles. Syntax highlighting styles are only considered if syntax highlighting is turned on. $modified True if the file in the current window has been modified and the modifications have not yet been saved. $VERSION Returns NEdit-ng's version number, in the format \"YYYYRRR\" ( \"2019004\" for NEdit-ng 2019.4). $n_display_lines The number of lines visible in the currently active pane. $n_panes The number of panes in the current window. $overtype_mode True if in Overtype mode. $read_only True if the file is read only. $selection_start, $selection_end Beginning and ending positions of the primary selection in the current window, or -1 if there is no text selected in the current window. $selection_left, $selection_right Left and right character offsets of the rectangular (primary) selection in the current window, or -1 if there is no selection or it is not rectangular. $server_name Name of the current NEdit-ng server. $show_line_numbers Whether line numbers are shown next to the text. $show_matching Contains the current preference for showing matching pairs, such as \"[]\" and \"{}\" pairs. Can be \"off\" , \"delimiter\" , or \"range\" . $match_syntax_based Whether pair matching should use syntax information, if available. $statistics_line Has a value of 1 if the statistics line is shown, otherwise 0 . $sub_sep Contains the value of the array sub-script separation string. $tab_dist The distance between tab stops for a hardware tab character, as set in the Preferences \u2192 Tab Stops... dialog. $text_length The length of the text in the current document. $top_line The line number of the top line of the currently active pane. $use_tabs Whether the user is allowing the NEdit-ng to insert tab characters to maintain spacing in tab emulation and rectangular dragging operations. (The setting of the Use tab characters in padding and emulated tabs button in the Preferences \u2192 Tab Stops... dialog.) $wrap_margin The right margin in the current window for text wrapping and filling. $wrap_text The current wrap text mode. Values are \"none\", \"auto\" or \"continuous\".","title":"Built in Variables"},{"location":"24/#built-in-subroutines","text":"append_file( string, filename ) Appends a string to a named file. Returns 1 on successful write, or 0 if unsuccessful. beep() Ring the bell. calltip( \"text_or_key\" [, pos [, mode or position_modifier, ...]] ) Pops up a calltip. <pos> is an optional position in the buffer where the tip will be displayed. Passing -1 for <pos> is equivalent to not specifying a position, and it guarantees that the tip will appear on-screen somewhere even if the cursor is not. The upper-left corner of the calltip will appear below where the cursor would appear if it were at this position. <mode> is one of \"tipText\" (default), \"tipKey\" , or \"tagKey\" . \"tipText\" displays the text as-is, \"tagKey\" uses it as the key to look up a tag, then converts the tag to a calltip, and \"tipKey\" uses it as the key to look up a calltip, then falls back to \"tagKey\" behavior if that fails. You'll usually use \"tipKey\" or \"tipText\" . Finally, you can modify the placement of the calltip relative to the cursor position (or <pos> ) with one or more of these optional position modifiers: \"center\" aligns the center of the calltip with the position. \"right\" aligns the right edge of the calltip with the position. ( \"center\" and \"right\" may not both be used.) \"above\" places the calltip above the position. \"strict\" does not allow the calltip to move from its position in order to avoid going off-screen or obscuring the cursor. Returns the ID of the calltip if it was found and/or displayed correctly, 0 otherwise. clipboard_to_string() Returns the contents of the clipboard as a macro string. Returns empty string on error. dialog( message, btn_1_label, btn_2_label, ... ) Pop up a dialog for querying and presenting information to the user. First argument is a string to show in the message area of the dialog. Additional optional arguments represent labels for buttons to appear along the bottom of the dialog. Returns the number of the button pressed (the first button is number 1 ), or 0 if the user closed the dialog via the window close box. filename_dialog( [title[, mode[, defaultPath[, filter[, defaultName]]]]] ) Presents a file selection dialog with the given title to the user that prompts for a new or existing file. Options are: <title> will be the title of the dialog, defaults to \"Choose file\". If <mode> is set to \"exist\" (default), the dialog will only allow the user to select files which already exist. If it is set to \"new\" , then, the user may specify any valid filename regardless of a file existing with that name or not. <defaultPath> is the default path to use. Default (or \"\" ) will use the active document's directory. <filter> is the file glob which determines which files to display. Is set to \"*\" if filter is \"\" and by default. <defaultName> is the default filename that is filled in automatically. Returns \"\" if the user cancelled the dialog, otherwise returns the fully-qualified path, including the filename. focus_window( window_name ) Sets the window on which subsequent macro commands operate. <window_name> can be either a fully qualified file name, or a relative filename (which will be completed from NEdit-ng's working directory) or one of \"last\" for the last window created, or \"next\" for the next window in the chain from the currently focused window (the first window being the one returned from calling focus_window(\"last\") . Returns the name of the newly-focused window, or an empty string if the requested window was not found. get_character( position ) Returns the single character at the position indicated by the first argument to the routine from the current window. get_range( start, end ) Returns the text between a starting and ending position from the current window. get_selection() Returns a string containing the text currently selected by the primary selection either from the current window (no keyword), or from anywhere on the screen (keyword \"any\"). getenv( name ) Gets the value of an environment variable. kill_calltip( [calltip_ID] ) Kills any calltip that is being displayed in the window in which the macro is running. If there is no displayed calltip this does nothing. If a calltip ID is supplied then the calltip is killed only if its ID is <calltip_ID> . length( string ) Returns the length of a string list_dialog( message, text, btn_1_label, btn_2_label, ... ) Pop up a dialog for prompting the user to choose a line from the given text string. The first argument is a message string to be used as a title for the fixed text describing the list. The second string provides the list data: this is a text string in which list entries are separated by newline characters. Additional optional arguments represent labels for buttons to appear along the bottom of the dialog. Returns the line of text selected by the user as the function value (without any newline separator) or the empty string if none was selected, and number of the button pressed (the first button is number 1 ), in $list_dialog_button . If the user closes the dialog via the window close box, the function returns the empty string, and $list_dialog_button returns 0 . max( n1, n2, ... ) Returns the maximum value of all of its arguments min( n1, n2, ... ) Returns the minimum value of all of its arguments read_file( filename ) Reads the contents of a text file into a string. On success, returns 1 in $read_status , and the contents of the file as a string in the subroutine return value. On failure, returns the empty string \"\" and a 0 $read_status . replace_in_string( string, search_for, replace_with [, type, \"copy\"] ) Replaces all occurrences of a search string in a string with a replacement string. Arguments are 1: string to search in, 2: string to search for, 3: replacement string. There are two optional arguments. One is a search type, either \"literal\" , \"case\" , \"word\" , \"caseWord\" , \"regex\" , or \"regexNoCase\" . The default search type is \"literal\" . If the optional \"copy\" argument is specified, a copy of the input string is returned when no replacements were performed. By default an empty string ( \"\" ) will be returned in this case. Returns a new string with all of the replacements done. replace_range( start, end, string ) Replaces all the text between two positions in the current window. If the cursor position is between start and end it will be set to start. replace_selection( string ) Replaces the primary-selection selected text in the current window. replace_substring( string, start, end, replace_with ) Replacing a substring between two positions in a string within another string. revert_to_saved() Reloads the file, discarding all changes done to the document by the user since the last save. search( search_for, start [, search_type, wrap, direction] ) Searches silently in a window without dialogs, beeps, or changes to the selection. Arguments are: 1: string to search for, 2: starting position. Optional arguments may include the strings: \"wrap\" to make the search wrap around the beginning or end of the string, \"backward\" or \"forward\" to change the search direction ( \"forward\" is the default), \"literal\" , \"case\" , \"word\" , \"caseWord\" , \"regex\" , or \"regexNoCase\" to change the search type (default is \"literal\" ). Returns the starting position of the match, or -1 if nothing matched. Also returns the ending position of the match in $search_end . search_string( string, search_for, start [, search_type, direction] ) Built-in macro subroutine for searching a string. Arguments are 1: string to search in, 2: string to search for, 3: starting position. Optional arguments may include the strings: \"wrap\" to make the search wrap around the beginning or end of the string, \"backward\" or \"forward\" to change the search direction ( \"forward\" is the default), \"literal\" , \"case\" , \"word\" , \"caseWord\" , \"regex\" , or \"regexNoCase\" to change the search type (default is \"literal\" ). Returns the starting position of the match, or -1 if nothing matched. Also returns the ending position of the match in $search_end . select( start, end ) Selects (with the primary selection) text in the current buffer between a starting and ending position. select_rectangle( start, end, left, right ) Selects a rectangular area of text between a starting and ending position, and confined horizontally to characters displayed between positions \"left\" , and \"right\" . set_cursor_pos( position ) Set the cursor position for the current window. shell_command( command, input_string ) Executes a shell command, feeding it input from input_string . On completion, output from the command is returned as the function value, and the command's exit status is returned in the global variable $shell_cmd_status . split(string, separation_string [, search_type]) Splits a string using the separator specified. Optionally the <search_type> argument can specify how the <separation_string> is interpreted. The default is \"literal\" . The returned value is an array with keys beginning at 0 . string_dialog( message, btn_1_label, btn_2_label, ... ) Pops up a dialog prompting the user to enter information. The first argument is a string to show in the message area of the dialog. Additional optional arguments represent labels for buttons to appear along the bottom of the dialog. Returns the string entered by the user as the function value, and number of the button pressed (the first button is number 1 ), in $string_dialog_button . If the user closes the dialog via the window close box, the function returns the empty string, and $string_dialog_button returns 0 . string_compare(string1, string2 [, consider-case]) Compare two strings and return 0 if they are equal, -1 if string1 is lexicographically less than string2 or 1 if string1 is lexicographically greater than string2. The values for the optional consider-case argument is either \"case\" or \"nocase\" . The default is to do a case sensitive comparison. string_to_clipboard( string ) Copy the contents of a macro string to the clipboard. substring( string, start [, end] ) Returns the portion of a string between a start and end position (with the position of the beginning of the string being 0 ). If end is missing, the position of the end of the string is used. If either of the positions are negative, they are treated as relative to the end of the string. A position specified either before the start of the string or after the end of the string is repositioned to the nearest valid string position. If the start position is beyond the end position, the empty string is returned. t_print( string1, string2, ... ) Writes strings to the terminal (stdout) from which NEdit-ng was started. tolower( string ) Return an all lower-case version of string . toupper( string ) Return an all upper-case version of string . valid_number( string ) Returns 1 if the string can be converted to a number without error following the same rules that the implicit conversion would. Otherwise 0 . write_file( string, filename ) Writes a string (parameter 1) to a file named in parameter 2. Returns 1 on successful write, or 0 if unsuccessful.","title":"Built-in Subroutines"},{"location":"24/#deprecated-functions","text":"Some functions are included only for supporting legacy macros. You should not use any of these functions in any new macro you write. match() DEPRECATED Use select_to_matching() instead.","title":"Deprecated Functions"},{"location":"24/#deprecated-built-in-variables","text":"Some global variables no longer have a practical meaning in NEdit-ng. You should not use any of these variables in any new macro you write. $font_name_bold Contains the current bold text font name. DEPRECATED NEdit has dropped support for simultanious different fonts, use $font_name $font_name_bold_italic Contains the current bold-italic text font name. DEPRECATED NEdit has dropped support for simultanious different fonts, use $font_name $font_name_italic Contains the current italic text font name. DEPRECATED NEdit has dropped support for simultanious different fonts, use $font_name","title":"Deprecated Built in Variables"},{"location":"25/","text":"Rangesets are a tool of the macro language to tag parts, or ranges, of the text, which shall be viewed as a group. A range is merely a contiguous range of characters between a start and an end position in the document, and a set of ranges belonging together is called a rangeset. So, a rangeset is nothing but an in general non-contiguous part of the text. Rangesets can be assigned a background color to make them visible: characters within all ranges of a rangeset will have the background color of the rangeset. (If more than one rangeset includes a given character, its background color will be that of the most recently created rangeset which has a color defined.) Applications of rangesets are for example: Showing differences between two versions of a file. Then, one rangeset would be those parts of the current file that are not in the prior version. Highlighting all occurrences of a particular pattern, e.g. showing all the strings 'foobar' in the file. Highlighting spelling mistakes found by a spell-checker. Rangesets are manipulated only through macro routines. Rangesets must be created first using the rangeset_create() function, which will return an identifier for the newly-created (empty) rangeset. This identifier is then passed to the other rangeset functions to manipulate the rangeset. For example, ranges are added to a rangeset with the rangeset_add() function. Notice that the ranges inside a rangeset do not have a particular identity. Only, they are given a (dynamically changing) numeric index, counting from 1, in the order of appearance in the text buffer. The ranges are adjusted when modifications are made to the text buffer: they shift around when characters are added or deleted staying with the original strings of characters. However, ranges within a set will coalesce if the characters between them are removed, or a new range is added to the set which bridges or overlaps others. For more on this, see How rangesets change with modifications . There is a limit to the number of rangesets which can exist at any time \u2014 currently up to 63 in each document. Care should be taken to destroy any rangesets which are no longer needed, by using the rangeset_destroy() function, if this limit is reached. Rangesets can be named: this is useful for macros which need a fixed identification for rangesets which are used for the same purpose in different documents. Although a new rangeset's number is arbitrary, its name can be fixed. This is done using the rangeset_set_name() function. Note that rangeset names within a particular document may not be unique. For this reason, the rangeset_get_by_name() function returns an array of identifiers, which will be empty if the name has not been associated with a rangeset. How rangesets change with modifications When changes are made to the document text, ranges within each set are altered with it, according to their behavioral mode. If changes are made outside of the ranges in a rangeset, each range simply maintains its size and adjusts its position to match the changes. When text within a range is deleted, the range's length is reduced by the same amount. When changes involving new text are made within a range of the set, or to one of the extremities of a range, different behaviours may be desirable. The rangeset_set_mode() function allows these modes to be chosen. Note that the precise behaviour of these modes may change in future versions of NEdit-ng. The available modes are: maintain or ins_del \u2014 Both these modes have the same behaviour. New text added at the front of a range in a set is not added to the range; new text added within the range or at the end extends the range. Replacement overlapping an extremity of the set acts as if the new text were added first, then the old text deleted. This causes curtailment at the front of the range, extension at the end. Replacement of the full text of the range removes the range from the set. The default behaviour for a newly created rangeset is maintain. del_ins \u2014 New text added at the front or end of a range in a set is not added to the range; new text added within the range extends the range. Replacement overlapping an extremity of the set acts as if the old text were deleted first, then the new text added. This causes curtailment at either end. Replacement of the full text of the range removes the range from the set. include \u2014 New text added at the front or end of a range in a set extends the range, as does new text added within the range. Replacement overlapping an extremity of the set acts as if the new text were added first, then the old text deleted. This causes curtailment at the front of the range, extension at the end. Replacement of the full text of the range adds the new text to the range if the start position of the replacement is at the range's start point. exclude \u2014 New text added at the front or end of a range in a set does not extend the range; new text added within the range extends the range. Replacement overlapping an extremity causes curtailment of the range. Replacement of the full text of the range removes the range from the set. break \u2014 New text added at the front or end of a range in a set does not extend the range; new text added within the range will split the range. Replacement overlapping an extremity causes curtailment of the range. Replacement of the full text of the range removes the range from the set. Notes A rangeset is manipulated only through macro routines. Rangesets can easily become very large, and may exceed the capacity of the running process. Coloring relies on proper color names or specifications (such as the \"#rrggbb\" hexadecimal digit strings), and appropriate hardware support. If an invalid color name is given, the default background color is used instead. Behaviours set using rangeset_set_mode() are subject to change in future versions. Rangeset read-only variables $rangeset_list array of active rangeset identifiers, with integer keys starting at 0, in the order the rangesets were defined. Rangeset functions rangeset_create() rangeset_create( n ) Creates one or more new rangesets. The first form creates a single range set and returns its identifier; if there are no rangesets available it returns 0. The second form creates n new rangesets, and returns an array of the rangeset identifiers with keys beginning at If the requested number of rangesets is not available it returns an empty array. rangeset_destroy( r ) rangeset_destroy( array ) Deletes all information about a rangeset or a number of rangesets. The first form destroys the rangeset identified by r. The second form should be passed an array of rangeset identifiers with keys beginning at 0 (i.e. the same form of array returned by rangeset_create(n) ; it destroys all the rangesets appearing in the array. If any of the rangesets do not exist, the function continues without errors. Does not return a value. rangeset_add( r ) rangeset_add( r, start, end ) rangeset_add( r, r0 ) Adds to the rangeset r. The first form adds the range identified by the current primary selection to the rangeset, unless the selection is rectangular. The second form adds the range defined by the start and end positions given. The third form adds all ranges in the rangeset r0 to the rangeset r, and returns 0. Returns the index of the newly-added range within the rangeset. rangeset_subtract( r, [start, end] ) rangeset_subtract( r, r0 ) Removes from the rangeset r. The first form removes the range identified by the current primary selection from the rangeset, unless start and end are defined, in which case the range they define is removed. The second form removes all ranges in the rangeset r0 from the rangeset r. Does not return a value. rangeset_invert( r ) Changes the rangeset r so that it contains all ranges not in r. Does not return a value. rangeset_get_by_name( name ) Returns an array of active rangeset identifiers, with integer keys starting at 0, whose name matches name. rangeset_info( r ) Returns an array containing information about the rangeset r. The array has the following keys: defined (whether a rangeset with identifier r is defined), count (the number of ranges in the rangeset), color (the current background color of the rangeset, an empty string if the rangeset has no color), name (the user supplied name of the rangeset, an empty string if the rangeset has no name), and mode (the name of the modify-response mode of the rangeset). rangeset_range( r, [index] ) Returns details of a specific range in the rangeset r. The range is specified by index, which should be between 1 and n (inclusive), where n is the number of ranges in the rangeset. The return value is an array containing the keys start (the start position of the range) and end (the end position of the range). If index is not supplied, the region returned is the span of the entire rangeset (the region starting at the start of the first range and ending at the end of the last). If index is outside the correct range of values, the function returns an empty array. rangeset_includes( r, pos ) Returns the index of the range in rangeset r which includes pos; returns 0 if pos is not contained in any of the ranges of r. This can also be used as a simple true/false function which returns true if pos is contained in the rangeset. rangeset_set_color( r, color ) Attempts to apply the color as a background color to the ranges of r. If color is at empty string, removes the coloring of r. No check is made regarding the validity of color: if the color is invalid (a bad name, or not supported by the hardware) this has unpredictable effects. rangeset_set_name( r, name ) Apply the name to the rangeset r. rangeset_set_mode( r, type ) Changes the behaviour of the rangeset r when modifications to the text buffer occur. type can be one of the following: maintain (the default), break , include , exclude , ins_del or del_ins . (These modes are described above.)","title":"Rangesets"},{"location":"25/#how-rangesets-change-with-modifications","text":"When changes are made to the document text, ranges within each set are altered with it, according to their behavioral mode. If changes are made outside of the ranges in a rangeset, each range simply maintains its size and adjusts its position to match the changes. When text within a range is deleted, the range's length is reduced by the same amount. When changes involving new text are made within a range of the set, or to one of the extremities of a range, different behaviours may be desirable. The rangeset_set_mode() function allows these modes to be chosen. Note that the precise behaviour of these modes may change in future versions of NEdit-ng. The available modes are: maintain or ins_del \u2014 Both these modes have the same behaviour. New text added at the front of a range in a set is not added to the range; new text added within the range or at the end extends the range. Replacement overlapping an extremity of the set acts as if the new text were added first, then the old text deleted. This causes curtailment at the front of the range, extension at the end. Replacement of the full text of the range removes the range from the set. The default behaviour for a newly created rangeset is maintain. del_ins \u2014 New text added at the front or end of a range in a set is not added to the range; new text added within the range extends the range. Replacement overlapping an extremity of the set acts as if the old text were deleted first, then the new text added. This causes curtailment at either end. Replacement of the full text of the range removes the range from the set. include \u2014 New text added at the front or end of a range in a set extends the range, as does new text added within the range. Replacement overlapping an extremity of the set acts as if the new text were added first, then the old text deleted. This causes curtailment at the front of the range, extension at the end. Replacement of the full text of the range adds the new text to the range if the start position of the replacement is at the range's start point. exclude \u2014 New text added at the front or end of a range in a set does not extend the range; new text added within the range extends the range. Replacement overlapping an extremity causes curtailment of the range. Replacement of the full text of the range removes the range from the set. break \u2014 New text added at the front or end of a range in a set does not extend the range; new text added within the range will split the range. Replacement overlapping an extremity causes curtailment of the range. Replacement of the full text of the range removes the range from the set.","title":"How rangesets change with modifications"},{"location":"25/#notes","text":"A rangeset is manipulated only through macro routines. Rangesets can easily become very large, and may exceed the capacity of the running process. Coloring relies on proper color names or specifications (such as the \"#rrggbb\" hexadecimal digit strings), and appropriate hardware support. If an invalid color name is given, the default background color is used instead. Behaviours set using rangeset_set_mode() are subject to change in future versions.","title":"Notes"},{"location":"25/#rangeset-read-only-variables","text":"$rangeset_list array of active rangeset identifiers, with integer keys starting at 0, in the order the rangesets were defined.","title":"Rangeset read-only variables"},{"location":"25/#rangeset-functions","text":"rangeset_create() rangeset_create( n ) Creates one or more new rangesets. The first form creates a single range set and returns its identifier; if there are no rangesets available it returns 0. The second form creates n new rangesets, and returns an array of the rangeset identifiers with keys beginning at If the requested number of rangesets is not available it returns an empty array. rangeset_destroy( r ) rangeset_destroy( array ) Deletes all information about a rangeset or a number of rangesets. The first form destroys the rangeset identified by r. The second form should be passed an array of rangeset identifiers with keys beginning at 0 (i.e. the same form of array returned by rangeset_create(n) ; it destroys all the rangesets appearing in the array. If any of the rangesets do not exist, the function continues without errors. Does not return a value. rangeset_add( r ) rangeset_add( r, start, end ) rangeset_add( r, r0 ) Adds to the rangeset r. The first form adds the range identified by the current primary selection to the rangeset, unless the selection is rectangular. The second form adds the range defined by the start and end positions given. The third form adds all ranges in the rangeset r0 to the rangeset r, and returns 0. Returns the index of the newly-added range within the rangeset. rangeset_subtract( r, [start, end] ) rangeset_subtract( r, r0 ) Removes from the rangeset r. The first form removes the range identified by the current primary selection from the rangeset, unless start and end are defined, in which case the range they define is removed. The second form removes all ranges in the rangeset r0 from the rangeset r. Does not return a value. rangeset_invert( r ) Changes the rangeset r so that it contains all ranges not in r. Does not return a value. rangeset_get_by_name( name ) Returns an array of active rangeset identifiers, with integer keys starting at 0, whose name matches name. rangeset_info( r ) Returns an array containing information about the rangeset r. The array has the following keys: defined (whether a rangeset with identifier r is defined), count (the number of ranges in the rangeset), color (the current background color of the rangeset, an empty string if the rangeset has no color), name (the user supplied name of the rangeset, an empty string if the rangeset has no name), and mode (the name of the modify-response mode of the rangeset). rangeset_range( r, [index] ) Returns details of a specific range in the rangeset r. The range is specified by index, which should be between 1 and n (inclusive), where n is the number of ranges in the rangeset. The return value is an array containing the keys start (the start position of the range) and end (the end position of the range). If index is not supplied, the region returned is the span of the entire rangeset (the region starting at the start of the first range and ending at the end of the last). If index is outside the correct range of values, the function returns an empty array. rangeset_includes( r, pos ) Returns the index of the range in rangeset r which includes pos; returns 0 if pos is not contained in any of the ranges of r. This can also be used as a simple true/false function which returns true if pos is contained in the rangeset. rangeset_set_color( r, color ) Attempts to apply the color as a background color to the ranges of r. If color is at empty string, removes the coloring of r. No check is made regarding the validity of color: if the color is invalid (a bad name, or not supported by the hardware) this has unpredictable effects. rangeset_set_name( r, name ) Apply the name to the rangeset r. rangeset_set_mode( r, type ) Changes the behaviour of the rangeset r when modifications to the text buffer occur. type can be one of the following: maintain (the default), break , include , exclude , ins_del or del_ins . (These modes are described above.)","title":"Rangeset functions"},{"location":"26/","text":"The user can interrogate the current window to determine the color highlighting used on a particular piece of text. The following functions provide information on the highlighting pattern against which text at a particular position has been matched, its style, color and font attributes (whether the font is supposed to be bold and/or italic). These macro functions permit macro writers to generate formatted output which allows NEdit-ng highlighting to be reproduced. This is suitable for the generation of HTML or Postscript output, for example. Note that if any of the functions is used while in Plain mode or while syntax highlighting is off, the behaviour is undefined. get_pattern_by_name( pattern_name ) Returns an array containing the pattern attributes for pattern pattern_name . The elements in this array are: style Highlight style name If pattern_name is invalid, an empty array is returned. get_pattern_at_pos( pos ) Returns an array containing the pattern attributes of the character at position pos . The elements in this array are: pattern Highlight pattern name style Highlight style name extent The length in the text which uses the same highlighting pattern The extent value is measured from position pos going right/down (forward in the file) only. If pos is invalid, an empty array is returned. get_style_by_name( style_name ) Returns an array containing the style attributes for style style_name . The elements in this array are: bold 1 if style is bold, 0 otherwise italic 1 if style is italic, 0 otherwise color Name of the style's color background Name of the background color, if any The colors use the names specified in the color definitions for the style. These will either be names matching those the X server recognises, or RGB (red/green/blue) specifications. If style_name is invalid, an empty array is returned. get_style_at_pos( pos ) Returns an array containing the style attributes of the character at position pos . The elements in this array are: style Name of the highlight style bold 1 if style is bold, 0 otherwise italic 1 if style is italic, 0 otherwise color Name of the style's color rgb Color's RGB values ('#rrggbb') background Name of the background color, if any back_rgb Background color's RGB values ('#rrggbb') extent The length in the text which uses the same highlight style The colors use the names specified in the color definitions for the style. These will either be names matching those the display server recognises, or RGB specifications. The values for rgb and back_rgb contain the actual color values allocated by the display server for the window. If the display cannot match the specified (named) color exactly, the RGB values in these entries may not match the specified ones. The extent value is measured from position pos going right/down (forward in the file) only. If pos is invalid, an empty array is returned.","title":"Highlighting Information"},{"location":"27/","text":"All of the editing capabilities of NEdit-ng are represented as a special type of subroutine, called an action routine, which can be invoked from both macros and translation table entries (see Key Binding ). Actions Representing Menu Commands File Menu new() open() open_dialog() open_selected() close() save() save_as() save_as_dialog() revert_to_saved_dialog() include_file() include_file_dialog() load_macro_file() load_macro_file_dialog() load_tags_file() load_tags_file_dialog() unload_tags_file() load_tips_file() load_tips_file_dialog() unload_tips_file() print() print_selection() exit() Edit Menu undo() redo() delete() select_all() shift_left() shift_left_by_tab() shift_right() shift_right_by_tab() uppercase() lowercase() fill_paragraph() control_code_dialog() Search Menu find() find_dialog() find_again() find_selection() replace() replace_dialog() replace_all() replace_in_selection() replace_again() goto_line_number() goto_line_number_dialog() goto_selected() mark() mark_dialog() goto_mark() goto_mark_dialog() goto_matching() select_to_matching() find_definition() show_tip() Shell Menu filter_selection_dialog() filter_selection() execute_command() execute_command_dialog() execute_command_line() shell_menu_command() Macro Menu macro_menu_command() repeat_macro() repeat_dialog() Windows Menu split_pane() close_pane() detach_document() move_document_dialog() An action representing a menu command is usually named the same as its corresponding menu item except that all punctuation is removed, all letters are changed to lower case, and spaces are replaced with underscores. To present a dialog to ask the user for input, use the actions with the _dialog suffix. Actions without the _dialog suffix take the information from the routine's arguments (see below). Menu Action Routine Arguments Arguments are text strings enclosed in quotes. Below are the menu action routines which take arguments. Optional arguments are enclosed in [] . new( [\"tab\" | \"window\" | \"prefs\" | \"opposite\"] ) close( [\"prompt\" | \"save\" | \"nosave\"] ) execute_command( shell-command ) filter_selection( shell-command ) find( search-string [, search-direction] [, search-type] [, search-wrap] ) find_again( [search-direction] [, search-wrap] ) find_definition( [tag-name] ) find_dialog( [search-direction] [, search-type] [, keep-dialog] ) find_selection( [search-direction] [, search-wrap] [, non-regex-search-type] ) goto_line_number( [line-number] [, column-number] ) goto_mark( mark-letter ) include_file( filename ) load_tags_file( filename ) macro_menu_command( macro-menu-item-name ) mark( mark-letter ) open( filename ) replace( search-string, replace-string, [, search-direction] [, search-type] [, search-wrap] ) replace_again( [search-direction] [, search-wrap] ) replace_all( search-string, replace-string [, search-type] ) replace_dialog( [search-direction] [, search-type] [, keep-dialog] ) replace_in_selection( search-string, replace-string [, search-type] ) save_as( filename ) shell_menu_command( shell-menu-item-name ) unload_tags_file( filename ) Some notes on argument types above Arguments to new() \"tab\" Open a new tab \"window\" Open a new window \"prefs\" Follow the user's tab/window preference \"opposite\" Opposite of user's tab/window preference Default behaviour is \"prefs\" . filename Path names are relative to the directory from which NEdit-ng was started. Shell interpreted wildcards and ~ are not expanded. keep-dialog Either \"keep\" or \"nokeep\" . mark-letter The mark command limits users to single letters. Inside of macros, single digits are allowed as marks. These won't interfere with marks set by the user. macro-menu-item-name Name of the command exactly as specified in the Macro Menu dialogs. non-regex-search-type Either \"literal\" , \"case\", \"word\" , or \"caseWord\" . search-direction Either \"forward\" or \"backward\" . search-type Either \"literal\" , \"case\" , \"word\" , \"caseWord\" , \"regex\" , or \"regexNoCase\" . search-wrap Either \"wrap\" or \"nowrap\" . shell-menu-item-name Name of the command exactly as specified in the Shell Menu dialogs. Window Preferences Actions (Deprecated) NOTE: The following functions for setting preferences are all deprecated. There is a plan to revamp the preference system to be more like most modern editors; replacing the global and per-window settings with a single set of application wide settings controlled by singular settings dialog. set_auto_indent( \"off\" | \"on\" | \"smart\" ) Set auto indent mode for the current window. set_em_tab_dist( em-tab-distance ) Set the emulated tab size. An em-tab-distance value of 0 or less translates to no emulated tabs. Em-tab-distance must be smaller than 1000 . set_fonts( font-name, italic-font-name, bold-font-name, bold-italic-font-name ) Set all the fonts used for the current window. set_highlight_syntax( [0 | 1] ) Set syntax highlighting mode for the current window. A value of 0 turns it off and a value of 1 turns it on. If no parameters are supplied the option is toggled. set_incremental_backup( [0 | 1] ) Set incremental backup mode for the current window. A value of 0 turns it off and a value of 1 turns it on. If no parameters are supplied the option is toggled. set_incremental_search_line( [0 | 1] ) Show or hide the incremental search line for the current window. A value of 0 turns it off and a value of 1 turns it on. If no parameters are supplied the option is toggled. set_language_mode( language-mode ) Set the language mode for the current window. If the language mode is \"\" or unrecognized, it will be set to Plain. set_locked( [0 | 1] ) This only affects the locked status of a file, not its read-only status. Permissions are not changed. A value of 0 turns it off and a value of 1 turns it on. If no parameters are supplied the option is toggled. set_make_backup_copy( [0 | 1] ) Set whether backup copies are made during saves for the current window. A value of 0 turns it off and a value of 1 turns it on. If no parameters are supplied the option is toggled. set_overtype_mode( [0 | 1] ) Set overtype mode for the current window. A value of 0 turns it off and a value of 1 turns it on. If no parameters are supplied the option is toggled. set_show_line_numbers( [0 | 1] ) Show or hide line numbers for the current window. A value of 0 turns it off and a value of 1 turns it on. If no parameters are supplied the option is toggled. set_show_matching( \"off\" | \"delimiter\" | \"range\" ) Set show matching (...) mode for the current window. set_match_syntax_based( [0 | 1] ) Set whether matching should be syntax based for the current window. set_statistics_line( [0 | 1] ) Show or hide the statistics line for the current window. A value of 0 turns it off and a value of 1 turns it on. If no parameters are supplied the option is toggled. set_tab_dist( tab-distance ) Set the size of hardware tab spacing. Tab-distance must be a value greater than 0 and no greater than 20. set_use_tabs( [0 | 1] ) Set whether tab characters are used for the current window. A value of 0 turns it off (using space characters instead) and a value of 1 turns it on. If no parameters are supplied the option is toggled. set_wrap_margin( wrap-width ) Set the wrap width for text wrapping of the current window. A value of 0 means to wrap at window width. set_wrap_text( \"none\" | \"auto\" | \"continuous\" ) Set wrap text mode for the current window. Keyboard-Only Actions In addition to the arguments listed in the call descriptions below, any routine involving cursor movement can take the argument \"extend\" , meaning, adjust the primary selection to the new cursor position. Routines which take the \"extend\" argument as well as mouse dragging operations for both primary and secondary selections can take the optional keyword \"rect\" , meaning, make the selection rectangular. Any routine that accepts the \"scrollbar\" argument will move the display but not the cursor or selection. Routines that accept the \"nobell\" argument will fail silently without beeping, when that argument is supplied. backward_character( [\"nobell\"] ) Moves the cursor one character to the left. backward_paragraph([\"nobell\"] ) Moves the cursor to the beginning of the paragraph, or if the cursor is already at the beginning of a paragraph, moves the cursor to the beginning of the previous paragraph. Paragraphs are defined as regions of text delimited by one or more blank lines. backward_word( [\"nobell\"] ) Moves the cursor to the beginning of a word, or, if the cursor is already at the beginning of a word, moves the cursor to the beginning of the previous word. Word delimiters are user-settable, and defined by the X resource wordDelimiters. beginning_of_file( [\"scrollbar\"] ) Moves the cursor to the beginning of the file. beginning_of_line( [\"absolute\"] ) Moves the cursor to the beginning of the line. If \"absolute\" is given, always moves to the absolute beginning of line, regardless of the text wrapping mode. beginning_of_selection() Moves the cursor to the beginning of the selection without disturbing the selection. copy_clipboard() Copies the current selection to the clipboard. copy_primary() Copies the primary selection to the cursor. copy_to() If a secondary selection exists, copies the secondary selection to the cursor. If no secondary selection exists, copies the primary selection to the pointer location. copy_to_or_end_drag() Completes either a secondary selection operation, or a primary drag. If the user is dragging the mouse to adjust a secondary selection, the selection is copied and either inserted at the cursor location, or, if pending-delete is on and a primary selection exists in the window, replaces the primary selection. If the user is dragging a block of text (primary selection), completes the drag operation and leaves the text at its current location. cut_clipboard() Deletes the text in the primary selection and places it in the clipboard. cut_primary() Copies the primary selection to the cursor and deletes it at its original location. delete_selection() Deletes the contents of the primary selection. delete_next_character( [\"nobell\"] ) If a primary selection exists, deletes its contents. Otherwise, deletes the character following the cursor. delete_previous_character( [\"nobell\"] ) If a primary selection exists, deletes its contents. Otherwise, deletes the character before the cursor. delete_next_word( [\"nobell\"] ) If a primary selection exists, deletes its contents. Otherwise, deletes the word following the cursor. delete_previous_word( [\"nobell\"] ) If a primary selection exists, deletes its contents. Otherwise, deletes the word before the cursor. delete_to_start_of_line( [\"nobell\", \"wrap\"] ) If a primary selection exists, deletes its contents. Otherwise, deletes the characters between the cursor and the start of the line. If \"wrap\" is given, deletes to the previous wrap point or beginning of line, whichever is closest. delete_to_end_of_line( [\"nobell\", \"absolute\"] ) If a primary selection exists, deletes its contents. Otherwise, deletes the characters between the cursor and the end of the line. If \"absolute\" is given, always deletes to the absolute end of line, regardless of the text wrapping mode. deselect_all() De-selects the primary selection. end_of_file( [\"scrollbar\"] ) Moves the cursor to the end of the file. end_of_line( [\"absolute\"] ) Moves the cursor to the end of the line. If \"absolute\" is given, always moves to the absolute end of line, regardless of the text wrapping mode. end_of_selection() Moves the cursor to the end of the selection without disturbing the selection. exchange( [\"nobell\"] ) Exchange the primary and secondary selections. extend_adjust() Attached mouse-movement events to begin a selection between the cursor and the mouse, or extend the primary selection to the mouse position. extend_end() Completes a primary drag-selection operation. extend_start() Begins a selection between the cursor and the mouse. A drag-selection operation can be started with either extend_start() or grab_focus() . focus_pane( [relative-pane] | [positive-index] | [negative-index] ) Move the focus to the requested pane. Arguments can be specified in the form of a relative-pane ( \"first\" , \"last\" , \"next\" , \"previous\" ), a positive-index (numbers greater than 0 , 1 is the same as \"first\" ) or a negative-index (numbers less than 0 , -1 is the same as \"last\" ). forward_character() Moves the cursor one character to the right. forward_paragraph( [\"nobell\"] ) Moves the cursor to the beginning of the next paragraph. Paragraphs are defined as regions of text delimited by one or more blank lines. forward_word( [\"tail\"] [\"nobell\"] ) Moves the cursor to the beginning of the next word. Word delimiters are user-settable, and defined by the config.ini setting nedit.wordDelimiters . If the \"tail\" argument is supplied the cursor will be moved to the end of the current word or the end of the next word, if the cursor is between words. grab_focus() Moves the cursor to the mouse pointer location, and prepares for a possible drag-selection operation (bound to extend_adjust() ), or multi-click operation (a further grab_focus() action). If a second invocation of grab focus follows immediately, it selects a whole word, or a third, a whole line. insert_string( \"string\" ) If pending delete is on and the cursor is inside the selection, replaces the selection with \"string\". Otherwise, inserts \"string\" at the cursor location. key_select( \"direction\" [,\"nobell\"] ) Moves the cursor one character in \"direction\" ( \"left\" , \"right\" , \"up\" , or \"down\" ) and extends the selection. Same as forward/backward-character(\"extend\"), or process-up/down(\"extend\"), for compatibility with previous versions. last_document() Switches the active tab to the one that was previously active. move-destination() Moves the cursor to the pointer location without disturbing the selection. (This is an unusual way of working. We left it in for compatibility with previous versions, but if you actually use this capability, please send us some mail, otherwise it is likely to disappear in the future. move_to() If a secondary selection exists, deletes the contents of the secondary selection and inserts it at the cursor, or if pending-delete is on and there is a primary selection, replaces the primary selection. If no secondary selection exists, moves the primary selection to the pointer location, deleting it from its original position. move_to_or_end_drag() Completes either a secondary selection operation, or a primary drag. If the user is dragging the mouse to adjust a secondary selection, the selection is deleted and either inserted at the cursor location, or, if pending-delete is on and a primary selection exists in the window, replaces the primary selection. If the user is dragging a block of text (primary selection), completes the drag operation and deletes the text from its current location. newline() Inserts a newline character. If Auto Indent is on, lines up the indentation of the cursor with the current line. newline_and_indent() Inserts a newline character and lines up the indentation of the cursor with the current line, regardless of the setting of Auto Indent. newline_no_indent() Inserts a newline character, without automatic indentation, regardless of the setting of Auto Indent. next_document() Switches the active tab to the next one on the tab bar. next_page( [\"stutter\"] [\"column\"] [\"scrollbar\"] [\"nobell\"] ) Moves the cursor and scroll forward one page. The parameter \"stutter\" moves the cursor to the bottom of the display, unless it is already there, otherwise it will page down. The parameter \"column\" will maintain the preferred column while moving the cursor. page_left( [\"scrollbar\"] [\"nobell\"] ) Move the cursor and scroll left one page. page_right( [\"scrollbar\"] [\"nobell\"] ) Move the cursor and scroll right one page. paste_clipboard() Insert the contents of the clipboard at the cursor, or if pending delete is on, replace the primary selection with the contents of the clipboard. previous_document() Switches the active tab to the previous one on the tab bar. previous_page( [\"stutter\"] [\"column\"] [\"scrollbar\"] [\"nobell\"] ) Moves the cursor and scroll backward one page. The parameter \"stutter\" moves the cursor to the top of the display, unless it is already there, otherwise it will page up. The parameter \"column\" will maintain the preferred column while moving the cursor. process_bdrag() Same as secondary_or_drag_start() for compatibility with previous versions. process_cancel() Cancels the current extend_adjust() , secondary_adjust() , or secondary_or_drag_adjust() in progress. process_down( [\"nobell\", \"absolute\"] ) Moves the cursor down one line. If \"absolute\" is given, always moves to the next line in the text buffer, regardless of wrapping. process_return() Same as newline for compatibility with previous versions. process_shift_down( [\"nobell\", \"absolute\"] ) Same as process_down(\"extend\") for compatibility with previous versions. process_shift_up( [\"nobell\", \"absolute\"] ) Same as process_up(\"extend\") for compatibility with previous versions. process_tab() If tab emulation is turned on, inserts an emulated tab, otherwise inserts a tab character. process_up( [\"nobell\", \"absolute\"] ) Moves the cursor up one line. If \"absolute\" is given, always moves to the previous line in the text buffer, regardless of wrapping. raise_window([relative-window] | [positive-index] | [negative-index] [, \"focus\" | \"nofocus\"] ) Raise the current focused window to the front if no argument is supplied. Arguments can be specified in the form of a relative-window ( \"first\" , \"last\" , \"next\" , \"previous\" ), a positive-index (numbers greater than 0 , 1 is the same as \"last\" ) or a negative-index (numbers less than 0 , -1 is the same as \"first\" ). Moreover, it can be specified whether or not the raised window should request the input focus. By default, it depends on the value of the nedit.focusOnRaise setting (see Config Entries ) whether or not the input focus is requested. scroll_down( nUnits, [\"lines\" | \"pages\"] ) Scroll the display down (towards the end of the file) by a given number of units, units being lines or pages. Default units are lines. scroll_left( nPixels ) Scroll the display left by nPixels. scroll_right( nPixels ) Scroll the display right by nPixels. scroll_up( nUnits, [\"lines\" | \"pages\"] ) Scroll the display up (towards the beginning of the file) by a given number of units, units being lines or pages. Default units are lines. scroll_to_line( lineNum ) Scroll to position line number lineNum at the top of the pane. The first line of a file is line 1. secondary_adjust() Attached mouse-movement events to extend the secondary selection to the mouse position. secondary_or_drag_adjust() Attached mouse-movement events to extend the secondary selection, or reposition the primary text being dragged. Takes two optional arguments, \"copy\" , and \"overlay\" . \"copy\" leaves a copy of the dragged text at the site at which the drag began. \"overlay\" does the drag in overlay mode, meaning the dragged text is laid on top of the existing text, obscuring and ultimately deleting it when the drag is complete. secondary_or_drag_start() To be attached to a mouse down event. Begins drag selecting a secondary selection, or dragging the contents of the primary selection, depending on whether the mouse is pressed inside of an existing primary selection. secondary_start() To be attached to a mouse down event. Begin drag selecting a secondary selection. select_all() Select the entire file. self_insert() To be attached to a key-press event, inserts the character equivalent of the key pressed.","title":"Action Routines"},{"location":"27/#actions-representing-menu-commands","text":"","title":"Actions Representing Menu Commands"},{"location":"27/#file-menu","text":"new() open() open_dialog() open_selected() close() save() save_as() save_as_dialog() revert_to_saved_dialog() include_file() include_file_dialog() load_macro_file() load_macro_file_dialog() load_tags_file() load_tags_file_dialog() unload_tags_file() load_tips_file() load_tips_file_dialog() unload_tips_file() print() print_selection() exit()","title":"File Menu"},{"location":"27/#edit-menu","text":"undo() redo() delete() select_all() shift_left() shift_left_by_tab() shift_right() shift_right_by_tab() uppercase() lowercase() fill_paragraph() control_code_dialog()","title":"Edit Menu"},{"location":"27/#search-menu","text":"find() find_dialog() find_again() find_selection() replace() replace_dialog() replace_all() replace_in_selection() replace_again() goto_line_number() goto_line_number_dialog() goto_selected() mark() mark_dialog() goto_mark() goto_mark_dialog() goto_matching() select_to_matching() find_definition() show_tip()","title":"Search Menu"},{"location":"27/#shell-menu","text":"filter_selection_dialog() filter_selection() execute_command() execute_command_dialog() execute_command_line() shell_menu_command()","title":"Shell Menu"},{"location":"27/#macro-menu","text":"macro_menu_command() repeat_macro() repeat_dialog()","title":"Macro Menu"},{"location":"27/#windows-menu","text":"split_pane() close_pane() detach_document() move_document_dialog() An action representing a menu command is usually named the same as its corresponding menu item except that all punctuation is removed, all letters are changed to lower case, and spaces are replaced with underscores. To present a dialog to ask the user for input, use the actions with the _dialog suffix. Actions without the _dialog suffix take the information from the routine's arguments (see below).","title":"Windows Menu"},{"location":"27/#menu-action-routine-arguments","text":"Arguments are text strings enclosed in quotes. Below are the menu action routines which take arguments. Optional arguments are enclosed in [] . new( [\"tab\" | \"window\" | \"prefs\" | \"opposite\"] ) close( [\"prompt\" | \"save\" | \"nosave\"] ) execute_command( shell-command ) filter_selection( shell-command ) find( search-string [, search-direction] [, search-type] [, search-wrap] ) find_again( [search-direction] [, search-wrap] ) find_definition( [tag-name] ) find_dialog( [search-direction] [, search-type] [, keep-dialog] ) find_selection( [search-direction] [, search-wrap] [, non-regex-search-type] ) goto_line_number( [line-number] [, column-number] ) goto_mark( mark-letter ) include_file( filename ) load_tags_file( filename ) macro_menu_command( macro-menu-item-name ) mark( mark-letter ) open( filename ) replace( search-string, replace-string, [, search-direction] [, search-type] [, search-wrap] ) replace_again( [search-direction] [, search-wrap] ) replace_all( search-string, replace-string [, search-type] ) replace_dialog( [search-direction] [, search-type] [, keep-dialog] ) replace_in_selection( search-string, replace-string [, search-type] ) save_as( filename ) shell_menu_command( shell-menu-item-name ) unload_tags_file( filename )","title":"Menu Action Routine Arguments"},{"location":"27/#some-notes-on-argument-types-above","text":"Arguments to new() \"tab\" Open a new tab \"window\" Open a new window \"prefs\" Follow the user's tab/window preference \"opposite\" Opposite of user's tab/window preference Default behaviour is \"prefs\" . filename Path names are relative to the directory from which NEdit-ng was started. Shell interpreted wildcards and ~ are not expanded. keep-dialog Either \"keep\" or \"nokeep\" . mark-letter The mark command limits users to single letters. Inside of macros, single digits are allowed as marks. These won't interfere with marks set by the user. macro-menu-item-name Name of the command exactly as specified in the Macro Menu dialogs. non-regex-search-type Either \"literal\" , \"case\", \"word\" , or \"caseWord\" . search-direction Either \"forward\" or \"backward\" . search-type Either \"literal\" , \"case\" , \"word\" , \"caseWord\" , \"regex\" , or \"regexNoCase\" . search-wrap Either \"wrap\" or \"nowrap\" . shell-menu-item-name Name of the command exactly as specified in the Shell Menu dialogs.","title":"Some notes on argument types above"},{"location":"27/#window-preferences-actions-deprecated","text":"NOTE: The following functions for setting preferences are all deprecated. There is a plan to revamp the preference system to be more like most modern editors; replacing the global and per-window settings with a single set of application wide settings controlled by singular settings dialog. set_auto_indent( \"off\" | \"on\" | \"smart\" ) Set auto indent mode for the current window. set_em_tab_dist( em-tab-distance ) Set the emulated tab size. An em-tab-distance value of 0 or less translates to no emulated tabs. Em-tab-distance must be smaller than 1000 . set_fonts( font-name, italic-font-name, bold-font-name, bold-italic-font-name ) Set all the fonts used for the current window. set_highlight_syntax( [0 | 1] ) Set syntax highlighting mode for the current window. A value of 0 turns it off and a value of 1 turns it on. If no parameters are supplied the option is toggled. set_incremental_backup( [0 | 1] ) Set incremental backup mode for the current window. A value of 0 turns it off and a value of 1 turns it on. If no parameters are supplied the option is toggled. set_incremental_search_line( [0 | 1] ) Show or hide the incremental search line for the current window. A value of 0 turns it off and a value of 1 turns it on. If no parameters are supplied the option is toggled. set_language_mode( language-mode ) Set the language mode for the current window. If the language mode is \"\" or unrecognized, it will be set to Plain. set_locked( [0 | 1] ) This only affects the locked status of a file, not its read-only status. Permissions are not changed. A value of 0 turns it off and a value of 1 turns it on. If no parameters are supplied the option is toggled. set_make_backup_copy( [0 | 1] ) Set whether backup copies are made during saves for the current window. A value of 0 turns it off and a value of 1 turns it on. If no parameters are supplied the option is toggled. set_overtype_mode( [0 | 1] ) Set overtype mode for the current window. A value of 0 turns it off and a value of 1 turns it on. If no parameters are supplied the option is toggled. set_show_line_numbers( [0 | 1] ) Show or hide line numbers for the current window. A value of 0 turns it off and a value of 1 turns it on. If no parameters are supplied the option is toggled. set_show_matching( \"off\" | \"delimiter\" | \"range\" ) Set show matching (...) mode for the current window. set_match_syntax_based( [0 | 1] ) Set whether matching should be syntax based for the current window. set_statistics_line( [0 | 1] ) Show or hide the statistics line for the current window. A value of 0 turns it off and a value of 1 turns it on. If no parameters are supplied the option is toggled. set_tab_dist( tab-distance ) Set the size of hardware tab spacing. Tab-distance must be a value greater than 0 and no greater than 20. set_use_tabs( [0 | 1] ) Set whether tab characters are used for the current window. A value of 0 turns it off (using space characters instead) and a value of 1 turns it on. If no parameters are supplied the option is toggled. set_wrap_margin( wrap-width ) Set the wrap width for text wrapping of the current window. A value of 0 means to wrap at window width. set_wrap_text( \"none\" | \"auto\" | \"continuous\" ) Set wrap text mode for the current window.","title":"Window Preferences Actions (Deprecated)"},{"location":"27/#keyboard-only-actions","text":"In addition to the arguments listed in the call descriptions below, any routine involving cursor movement can take the argument \"extend\" , meaning, adjust the primary selection to the new cursor position. Routines which take the \"extend\" argument as well as mouse dragging operations for both primary and secondary selections can take the optional keyword \"rect\" , meaning, make the selection rectangular. Any routine that accepts the \"scrollbar\" argument will move the display but not the cursor or selection. Routines that accept the \"nobell\" argument will fail silently without beeping, when that argument is supplied. backward_character( [\"nobell\"] ) Moves the cursor one character to the left. backward_paragraph([\"nobell\"] ) Moves the cursor to the beginning of the paragraph, or if the cursor is already at the beginning of a paragraph, moves the cursor to the beginning of the previous paragraph. Paragraphs are defined as regions of text delimited by one or more blank lines. backward_word( [\"nobell\"] ) Moves the cursor to the beginning of a word, or, if the cursor is already at the beginning of a word, moves the cursor to the beginning of the previous word. Word delimiters are user-settable, and defined by the X resource wordDelimiters. beginning_of_file( [\"scrollbar\"] ) Moves the cursor to the beginning of the file. beginning_of_line( [\"absolute\"] ) Moves the cursor to the beginning of the line. If \"absolute\" is given, always moves to the absolute beginning of line, regardless of the text wrapping mode. beginning_of_selection() Moves the cursor to the beginning of the selection without disturbing the selection. copy_clipboard() Copies the current selection to the clipboard. copy_primary() Copies the primary selection to the cursor. copy_to() If a secondary selection exists, copies the secondary selection to the cursor. If no secondary selection exists, copies the primary selection to the pointer location. copy_to_or_end_drag() Completes either a secondary selection operation, or a primary drag. If the user is dragging the mouse to adjust a secondary selection, the selection is copied and either inserted at the cursor location, or, if pending-delete is on and a primary selection exists in the window, replaces the primary selection. If the user is dragging a block of text (primary selection), completes the drag operation and leaves the text at its current location. cut_clipboard() Deletes the text in the primary selection and places it in the clipboard. cut_primary() Copies the primary selection to the cursor and deletes it at its original location. delete_selection() Deletes the contents of the primary selection. delete_next_character( [\"nobell\"] ) If a primary selection exists, deletes its contents. Otherwise, deletes the character following the cursor. delete_previous_character( [\"nobell\"] ) If a primary selection exists, deletes its contents. Otherwise, deletes the character before the cursor. delete_next_word( [\"nobell\"] ) If a primary selection exists, deletes its contents. Otherwise, deletes the word following the cursor. delete_previous_word( [\"nobell\"] ) If a primary selection exists, deletes its contents. Otherwise, deletes the word before the cursor. delete_to_start_of_line( [\"nobell\", \"wrap\"] ) If a primary selection exists, deletes its contents. Otherwise, deletes the characters between the cursor and the start of the line. If \"wrap\" is given, deletes to the previous wrap point or beginning of line, whichever is closest. delete_to_end_of_line( [\"nobell\", \"absolute\"] ) If a primary selection exists, deletes its contents. Otherwise, deletes the characters between the cursor and the end of the line. If \"absolute\" is given, always deletes to the absolute end of line, regardless of the text wrapping mode. deselect_all() De-selects the primary selection. end_of_file( [\"scrollbar\"] ) Moves the cursor to the end of the file. end_of_line( [\"absolute\"] ) Moves the cursor to the end of the line. If \"absolute\" is given, always moves to the absolute end of line, regardless of the text wrapping mode. end_of_selection() Moves the cursor to the end of the selection without disturbing the selection. exchange( [\"nobell\"] ) Exchange the primary and secondary selections. extend_adjust() Attached mouse-movement events to begin a selection between the cursor and the mouse, or extend the primary selection to the mouse position. extend_end() Completes a primary drag-selection operation. extend_start() Begins a selection between the cursor and the mouse. A drag-selection operation can be started with either extend_start() or grab_focus() . focus_pane( [relative-pane] | [positive-index] | [negative-index] ) Move the focus to the requested pane. Arguments can be specified in the form of a relative-pane ( \"first\" , \"last\" , \"next\" , \"previous\" ), a positive-index (numbers greater than 0 , 1 is the same as \"first\" ) or a negative-index (numbers less than 0 , -1 is the same as \"last\" ). forward_character() Moves the cursor one character to the right. forward_paragraph( [\"nobell\"] ) Moves the cursor to the beginning of the next paragraph. Paragraphs are defined as regions of text delimited by one or more blank lines. forward_word( [\"tail\"] [\"nobell\"] ) Moves the cursor to the beginning of the next word. Word delimiters are user-settable, and defined by the config.ini setting nedit.wordDelimiters . If the \"tail\" argument is supplied the cursor will be moved to the end of the current word or the end of the next word, if the cursor is between words. grab_focus() Moves the cursor to the mouse pointer location, and prepares for a possible drag-selection operation (bound to extend_adjust() ), or multi-click operation (a further grab_focus() action). If a second invocation of grab focus follows immediately, it selects a whole word, or a third, a whole line. insert_string( \"string\" ) If pending delete is on and the cursor is inside the selection, replaces the selection with \"string\". Otherwise, inserts \"string\" at the cursor location. key_select( \"direction\" [,\"nobell\"] ) Moves the cursor one character in \"direction\" ( \"left\" , \"right\" , \"up\" , or \"down\" ) and extends the selection. Same as forward/backward-character(\"extend\"), or process-up/down(\"extend\"), for compatibility with previous versions. last_document() Switches the active tab to the one that was previously active. move-destination() Moves the cursor to the pointer location without disturbing the selection. (This is an unusual way of working. We left it in for compatibility with previous versions, but if you actually use this capability, please send us some mail, otherwise it is likely to disappear in the future. move_to() If a secondary selection exists, deletes the contents of the secondary selection and inserts it at the cursor, or if pending-delete is on and there is a primary selection, replaces the primary selection. If no secondary selection exists, moves the primary selection to the pointer location, deleting it from its original position. move_to_or_end_drag() Completes either a secondary selection operation, or a primary drag. If the user is dragging the mouse to adjust a secondary selection, the selection is deleted and either inserted at the cursor location, or, if pending-delete is on and a primary selection exists in the window, replaces the primary selection. If the user is dragging a block of text (primary selection), completes the drag operation and deletes the text from its current location. newline() Inserts a newline character. If Auto Indent is on, lines up the indentation of the cursor with the current line. newline_and_indent() Inserts a newline character and lines up the indentation of the cursor with the current line, regardless of the setting of Auto Indent. newline_no_indent() Inserts a newline character, without automatic indentation, regardless of the setting of Auto Indent. next_document() Switches the active tab to the next one on the tab bar. next_page( [\"stutter\"] [\"column\"] [\"scrollbar\"] [\"nobell\"] ) Moves the cursor and scroll forward one page. The parameter \"stutter\" moves the cursor to the bottom of the display, unless it is already there, otherwise it will page down. The parameter \"column\" will maintain the preferred column while moving the cursor. page_left( [\"scrollbar\"] [\"nobell\"] ) Move the cursor and scroll left one page. page_right( [\"scrollbar\"] [\"nobell\"] ) Move the cursor and scroll right one page. paste_clipboard() Insert the contents of the clipboard at the cursor, or if pending delete is on, replace the primary selection with the contents of the clipboard. previous_document() Switches the active tab to the previous one on the tab bar. previous_page( [\"stutter\"] [\"column\"] [\"scrollbar\"] [\"nobell\"] ) Moves the cursor and scroll backward one page. The parameter \"stutter\" moves the cursor to the top of the display, unless it is already there, otherwise it will page up. The parameter \"column\" will maintain the preferred column while moving the cursor. process_bdrag() Same as secondary_or_drag_start() for compatibility with previous versions. process_cancel() Cancels the current extend_adjust() , secondary_adjust() , or secondary_or_drag_adjust() in progress. process_down( [\"nobell\", \"absolute\"] ) Moves the cursor down one line. If \"absolute\" is given, always moves to the next line in the text buffer, regardless of wrapping. process_return() Same as newline for compatibility with previous versions. process_shift_down( [\"nobell\", \"absolute\"] ) Same as process_down(\"extend\") for compatibility with previous versions. process_shift_up( [\"nobell\", \"absolute\"] ) Same as process_up(\"extend\") for compatibility with previous versions. process_tab() If tab emulation is turned on, inserts an emulated tab, otherwise inserts a tab character. process_up( [\"nobell\", \"absolute\"] ) Moves the cursor up one line. If \"absolute\" is given, always moves to the previous line in the text buffer, regardless of wrapping. raise_window([relative-window] | [positive-index] | [negative-index] [, \"focus\" | \"nofocus\"] ) Raise the current focused window to the front if no argument is supplied. Arguments can be specified in the form of a relative-window ( \"first\" , \"last\" , \"next\" , \"previous\" ), a positive-index (numbers greater than 0 , 1 is the same as \"last\" ) or a negative-index (numbers less than 0 , -1 is the same as \"first\" ). Moreover, it can be specified whether or not the raised window should request the input focus. By default, it depends on the value of the nedit.focusOnRaise setting (see Config Entries ) whether or not the input focus is requested. scroll_down( nUnits, [\"lines\" | \"pages\"] ) Scroll the display down (towards the end of the file) by a given number of units, units being lines or pages. Default units are lines. scroll_left( nPixels ) Scroll the display left by nPixels. scroll_right( nPixels ) Scroll the display right by nPixels. scroll_up( nUnits, [\"lines\" | \"pages\"] ) Scroll the display up (towards the beginning of the file) by a given number of units, units being lines or pages. Default units are lines. scroll_to_line( lineNum ) Scroll to position line number lineNum at the top of the pane. The first line of a file is line 1. secondary_adjust() Attached mouse-movement events to extend the secondary selection to the mouse position. secondary_or_drag_adjust() Attached mouse-movement events to extend the secondary selection, or reposition the primary text being dragged. Takes two optional arguments, \"copy\" , and \"overlay\" . \"copy\" leaves a copy of the dragged text at the site at which the drag began. \"overlay\" does the drag in overlay mode, meaning the dragged text is laid on top of the existing text, obscuring and ultimately deleting it when the drag is complete. secondary_or_drag_start() To be attached to a mouse down event. Begins drag selecting a secondary selection, or dragging the contents of the primary selection, depending on whether the mouse is pressed inside of an existing primary selection. secondary_start() To be attached to a mouse down event. Begin drag selecting a secondary selection. select_all() Select the entire file. self_insert() To be attached to a key-press event, inserts the character equivalent of the key pressed.","title":"Keyboard-Only Actions"},{"location":"28/","text":"NEdit-ng can be customized in many different ways. The most important user-settable options are presented in the Preferences menu, including all options that users might need to change during an editing session. Options set in Preferences \u2192 Default Settings can be preserved between sessions by selecting Preferences \u2192 Save Defaults , which writes the changes to the preferences file. See Preferences for more details. User defined commands can be added to NEdit-ng's Shell, Macro, and window background menus. Dialogs for creating items in these menus can be found under Preferences \u2192 Default Settings \u2192 Customize Menus . For users who depend on NEdit-ng every day and want to tune every excruciating detail, there are also configuration settings for tuning a vast number of such details, down to the color of each individual button. See Config Entries for more information, as well as a list of selected settings. The most common reason for customizing your Config Entries for NEdit-ng, however, is key binding. While limited key binding can be done through Preferences \u2192 Default Settings \u2192 Customize Menus , you can really only add keys this way, and each key must have a corresponding menu item. Any significant changes to key binding should be made via the Translations resource and menu accelerator resources. Key Binding and Config Entries have more information.","title":"Customizing NEdit-ng"},{"location":"29/","text":"The Preferences menu allows you to set options for both the current editing window, and default values for newly created windows and future NEdit-ng sessions. Options in the Preferences menu itself (not in Preferences \u2192 Default Settings ) take effect immediately and refer to the current window only. Options in Preferences \u2192 Default Settings provide initial settings for future windows created using the File \u2192 New or File \u2192 Open commands; options affecting all windows are also set here. Preferences set in Preferences \u2192 Default Settings are saved in files that NEdit-ng reads at startup time (see The NEdit-ng Autoload Files below), by selecting Preferences \u2192 Save Defaults . Preferences Menu Default Settings Menu of initial settings for future windows. Generally the same as the options in the main part of the menu, but apply as defaults for future windows created during this NEdit-ng session. These settings can be saved using the Save Defaults command below, to be loaded automatically each time NEdit-ng is started. Save Defaults Save the default options as set under Default Settings for future NEdit-ng sessions Statistics Line Show the full file name, line number, and length of the file being edited Incremental Search Line Keep the incremental search bar ( Search \u2192 Find Incremental ) permanently displayed at the top of the window Show Line Numbers Display line numbers to the left of the text Language Mode Tells NEdit-ng what language (if any) to assume, for selecting language-specific features such as highlight patterns and smart indent macros, and setting language specific preferences like word delimiters, tab emulation, and auto-indent. See Programming with NEdit-ng for more information Auto Indent Setting Auto Indent \"on\" maintains a running indent (pressing the Return key will line up the cursor with the indent level of the previous line). If smart indent macros are available for the current language mode, smart indent can be selected and NEdit-ng will attempt to guess proper language indentation for each new line, details at Auto/Smart Indent Wrap Choose between two styles of automatic wrapping or none. Auto Newline wrap, wraps text at word boundaries when the cursor reaches the right margin, by replacing the space or tab at the last word boundary with a newline character. Continuous Wrap wraps long lines which extend past the right margin. Continuous Wrap mode is typically used to produce files where newlines are omitted within paragraphs, to make text filling automatic (a kind of poor-man's word processor). Text of this style is common on Macs and PCs but is not necessarily supported very well under Unix (except in programs which deal with e-mail, for which it is often the format of choice) Wrap Margin Set margin for Auto Newline Wrap, Continuous Wrap, and Fill Paragraph. Lines may, be wrapped at the right margin of the window, or the margin can be set at a specific column Tab Stops Set the tab distance (number of characters between tab stops) for tab characters, and control tab emulation and use of tab characters in padding and emulated tabs Text Font... Change the font used to display text. See below for more information Highlight Syntax If NEdit-ng recognizes the language being edited, and highlighting patterns are available for that language, use fonts and colors to enhance viewing of the file. (See Syntax Highlighting for more information.) Make Backup Copy On Save, write a backup copy of the file as it existed before the Save command with the extension .bck Incremental Backup Periodically make a backup copy of the file being edited under the name ~filename (see Crash Recovery ) Show Matching (..) Momentarily highlight matching parenthesis, brackets, and braces, or the range between them, when one of these characters is typed, or when the insertion cursor is positioned after it. Delimiter only highlights the matching delimiter, while Range highlights the whole range of text between the matching delimiters Optionally, the matching can make use of syntax information if syntax highlighting is enabled. Alternatively, the matching is purely character based. In general, syntax based matching results in fewer false matches Overtype In overtype mode, new characters entered replace the characters in front of the insertion cursor, rather than being inserted before them Read Only Lock the file against accidental modification. This temporarily prevents the file from being modified in this NEdit-ng session. Note that this is different from setting the file protection Preferences \u2192 Default Settings Menu Options in Preferences \u2192 Default Settings have the same meaning as those in the top-level Preferences menu, except that they apply to future NEdit-ng windows and future NEdit-ng sessions if saved with Preferences \u2192 Save Defaults . Additional options which appear in this menu are: Language Modes Define language recognition information (for determining language mode from file name or content) and set language specific preferences. Tag Collisions How to react to multiple tags for the same name. Tags are described in Finding Declarations (ctags) . In Show All mode, all matching tags are displayed in a dialog. In Smart mode, if one of the matching tags is in the current window, that tag is chosen, without displaying the dialog. Command Shell... Set the shell used to run programs from the shell_command() macro function and from the Shell menu. This defaults to the user's login shell. Colors... Change the colors used to display text. The \"Matching (..)\" fields change the colors that matching parens, brackets and braces are flashed when the \"Show Matching (..)\" option is enabled. Note that the foreground colors for plain text, selected text, and matching paren flashing only apply when syntax highlighting is disabled. When syntax highlighting is enabled, text (even text that appears plain) will always be colored according to its highlighting style. (For information on changing syntax highlighting styles and matching patterns use see Syntax Highlighting .) Customize Menus Add/remove items from the Shell, Macro, and window background menus (see below). Customize Window Title Opens a dialog where the information to be displayed in the window's title field can be defined and tested. The dialog contains a Help button, providing further information about the options available. Searching Options for controlling the behavior of Search \u2192 Find and Search \u2192 Replace commands: Verbose Presents search results in dialog form, asks before wrapping a search back around the beginning (or end) of the file (unless Beep On Search Wrap is turned on). Wrap Around Search and Replace operations wrap around the beginning (or end) of the file. Beep On Search Wrap Beep when Search and Replace operations wrap around the beginning (or end) of the file (only if Wrap Around is turned on). Keep Dialogs Up Don't close Replace and Find boxes after searching. Default Search Style Initial setting for search type in Find and Replace dialogs. Initial setting for the scope in the Replace/Find dialog, when a selection exists. It can be either \"In Window\", \"In Selection\", or \"Smart\". \"Smart\" results in \"In Window\" if the size of the selection is smaller than 1 line, and to \"In Selection\" otherwise. Syntax Highlighting Program and configure enhanced text display for new or supported languages. (See Syntax Highlighting .) Tabbed Editing Options for controlling the tabbed interface: Open File in New Tab Open files in new tabs, else open files in new windows. Show Tab Bar Show/Hide the tab bar. Hide Tab Bar when only one Document is open Next/Prev Tabs Across Windows Suppose there are two windows with three tabs in the first window and two tabs in the second window. Enabling this option, if you are on the third tab in the first window, hitting Ctrl + PageDown would switch to the first tab in the second window (instead of switching to the first tab in the first window). Sort Tabs Alphabetically Show Tooltips Show file name and path in a tooltip when moving the mouse pointer over a tab. (See Tabbed Editing .) Terminate with Line Break on Save Some programs expect text files to end with a newline. If this option is activated, NEdit-ng will append one if not already present. Sort Open Prev. Menu Option to order File \u2192 Open Previous alphabetically, versus in order of last access. Popups Under Pointer Display pop-up dialogs centered on the current mouse position, as opposed to centered on the parent window. This generally speeds interaction, and is essential for users who set their window managers so keyboard focus follows the mouse. Auto-Scroll Near Window Top/Bottom When this option is enabled the window will automatically scroll when the cursor comes 4 lines from the top or bottom of the window (except at the beginning of the file). The number of lines can be customized with the nedit.autoScrollVPadding setting in the config.ini file. Warnings Options for controlling the popping up of warning dialogs: File Modified Externally Pop up a warning dialog when files get changed external to NEdit-ng. Check Modified File Contents If external file modification warnings are requested, also check the file contents iso. only the modification date. On Exit Ask before exiting when two or more files are open in an NEdit-ng session or before closing a window with two or more tabs. Initial Window Size Default size for new windows. Changing The Display Font The font used to display text in NEdit-ng is set under Preferences \u2192 Text Font (for the current window), or Preferences \u2192 Default Settings Text Font (for future windows). NEdit-ng shows a list of the monospaced fonts that are available on your system in this dialog. Customizing Menus You can add or change items in the Shell , Macro , and window background menus under Preferences \u2192 Default Settings \u2192 Customize Menus . When you choose one of these, you will see a dialog with a list of the current user-configurable items from the menu on the left. To change an existing item, select it from the list, and its properties will appear in the remaining fields of the dialog, where you may change them. Selecting the item New from the list allows you to enter new items in the menu. Hopefully most of the characteristics are self explanatory, but here are a few things to note: Accelerator keys are keyboard shortcuts which appear on the right hand side of the menus, and allow you avoid pulling down the menu and activate the command with a single keystroke. Enter accelerators by typing the keys exactly as you would to activate the command. Mnemonics are a single letter which should be part of the menu item name, which allow users to traverse and activate menu items by typing keys when the menu is pulled down. These are specified by placing & in the name immediately before the desired letter. For example, T&est will have e as its mnemonic. In the Shell Command field of the Shell Commands dialog, the % character expands to the name (including directory path) of the file in the window. To include a % character in the command, use %% . The Menu Entry field can contain special characters for constructing hierarchical sub-menus, and for making items which appear only in certain language modes. The right angle bracket character > creates a sub-menu. The name of the item itself should be the last element of the path formed from successive sub-menu names joined with > . Menu panes are called in to existence simply by naming them as part of a Menu Entry name. To put several items in the same sub-menu, repeat the same hierarchical sequence for each. For example, in the Macro Commands dialog, two items with menu entries: a>b>c and a>b>d would create a single sub menu under the macro menu called a , which would contain a single sub-menu, b , holding the actual items, c and d : +---++---++---+ |a >||b >||c | +---++---+|d | +---+ To qualify a menu entry with a language mode, simply add an at-sign @ at the end of the menu command, followed (no space) by a language mode name. To make a menu item which appears in several language modes, append additional @ s and language mode names. For example, an item with the menu entry: Make C Prototypes@C@C++ would appear only in C and C++ language modes, and: Make Class Template@C++ would appear only in C++ mode. Menu items with no qualification appear in all language modes. If a menu item is followed by the single language qualification @* , that item will appear only if there are no applicable language-specific items of the same name in the same submenu. For example, if you have the following three entries in the same menu: Make Prototypes@C@C++ Make Prototypes@Java Make Prototypes@* The first will be available when the language mode is C or C++, the second when the language mode is Java, and for all other language modes (including the \"Plain\" non-language mode). If the entry: Make Prototypes also exists, this will always appear, meaning that the menu will always have two \"Make Prototypes\" entries, whatever the language mode. The NEdit-ng Autoload Files At startup time, NEdit-ng automatically reads the following files: config.ini General configuration Contains saved preferences (menu settings) in the format of a Windows ini file. style.qss An optional Qt style sheet A Qt style sheet can be used to adjust the appearance of the NEdit-ng application. theme.xml A highlighting theme file Holds the text drawing styles defined using the Preferences \u2192 Default Settings \u2192 Syntax Highlighting \u2192 Text Drawing Styles dialog. autoload.nm An optional autoload macro file May provide macro commands and definitions for NEdit-ng to execute at startup (NEdit-ng doesn't create this file automatically). history The history database A list of recently opened files, which appear under File \u2192 Open Previous . These files are normally located in $HOME/.config/nedit-ng but may be elsewhere if the Qt Generic Config Location is different. Sharing Customizations with Other NEdit-ng Users If you have written Macro or Shell menu commands, highlight patterns, or smart-indent macros that you want to share with other NEdit-ng users, you can make a file which they can load into their NEdit-ng environment. To load such a file, start NEdit-ng with the command: nedit-ng -import <file> In the new NEdit-ng session, verify that the imported patterns or macros do what you want, then select Preferences \u2192 Save Defaults . Saving incorporates the changes into the NEdit-ng preferences file, so the next time you run NEdit-ng, you will not have to import the distribution file. Loading a customization file is automated, but creating one is not. To produce a file to be imported by other users, you must make a copy of your own preferences file, and edit it, by hand, to remove everything but the few items of interest to the recipient. Leave only the individual values(s), and within those values, only the particular macro, pattern, style, etc, that you wish to exchange. For example, to share a highlighting pattern set, you would include the patterns, any new styles you added, and language mode information only if the patterns are intended to support a new language rather than updating an existing one. For example: nedit.highlightPatterns:\\ My Language:1:0{\\n\\ Comment:\"#\":\"$\"::Comment::\\n\\ Loop Header:\"^[ \\\\t]*loop:\":::Loop::\\n\\ } nedit.languageModes: My Language:.my:::::: nedit.styles: Loop:blue:Bold Values are in the format of Windows ini files, but the format of text within multiple-item values like highlight patterns, language modes, macros, styles, etc., are private to NEdit-ng. NOTE: Future versions of NEdit-ng are expected to change this internal format to be spit among several YAML files for easier user editing and management.","title":"Preferences"},{"location":"29/#preferences-menu","text":"Default Settings Menu of initial settings for future windows. Generally the same as the options in the main part of the menu, but apply as defaults for future windows created during this NEdit-ng session. These settings can be saved using the Save Defaults command below, to be loaded automatically each time NEdit-ng is started. Save Defaults Save the default options as set under Default Settings for future NEdit-ng sessions Statistics Line Show the full file name, line number, and length of the file being edited Incremental Search Line Keep the incremental search bar ( Search \u2192 Find Incremental ) permanently displayed at the top of the window Show Line Numbers Display line numbers to the left of the text Language Mode Tells NEdit-ng what language (if any) to assume, for selecting language-specific features such as highlight patterns and smart indent macros, and setting language specific preferences like word delimiters, tab emulation, and auto-indent. See Programming with NEdit-ng for more information Auto Indent Setting Auto Indent \"on\" maintains a running indent (pressing the Return key will line up the cursor with the indent level of the previous line). If smart indent macros are available for the current language mode, smart indent can be selected and NEdit-ng will attempt to guess proper language indentation for each new line, details at Auto/Smart Indent Wrap Choose between two styles of automatic wrapping or none. Auto Newline wrap, wraps text at word boundaries when the cursor reaches the right margin, by replacing the space or tab at the last word boundary with a newline character. Continuous Wrap wraps long lines which extend past the right margin. Continuous Wrap mode is typically used to produce files where newlines are omitted within paragraphs, to make text filling automatic (a kind of poor-man's word processor). Text of this style is common on Macs and PCs but is not necessarily supported very well under Unix (except in programs which deal with e-mail, for which it is often the format of choice) Wrap Margin Set margin for Auto Newline Wrap, Continuous Wrap, and Fill Paragraph. Lines may, be wrapped at the right margin of the window, or the margin can be set at a specific column Tab Stops Set the tab distance (number of characters between tab stops) for tab characters, and control tab emulation and use of tab characters in padding and emulated tabs Text Font... Change the font used to display text. See below for more information Highlight Syntax If NEdit-ng recognizes the language being edited, and highlighting patterns are available for that language, use fonts and colors to enhance viewing of the file. (See Syntax Highlighting for more information.) Make Backup Copy On Save, write a backup copy of the file as it existed before the Save command with the extension .bck Incremental Backup Periodically make a backup copy of the file being edited under the name ~filename (see Crash Recovery ) Show Matching (..) Momentarily highlight matching parenthesis, brackets, and braces, or the range between them, when one of these characters is typed, or when the insertion cursor is positioned after it. Delimiter only highlights the matching delimiter, while Range highlights the whole range of text between the matching delimiters Optionally, the matching can make use of syntax information if syntax highlighting is enabled. Alternatively, the matching is purely character based. In general, syntax based matching results in fewer false matches Overtype In overtype mode, new characters entered replace the characters in front of the insertion cursor, rather than being inserted before them Read Only Lock the file against accidental modification. This temporarily prevents the file from being modified in this NEdit-ng session. Note that this is different from setting the file protection","title":"Preferences Menu"},{"location":"29/#preferences-default-settings-menu","text":"Options in Preferences \u2192 Default Settings have the same meaning as those in the top-level Preferences menu, except that they apply to future NEdit-ng windows and future NEdit-ng sessions if saved with Preferences \u2192 Save Defaults . Additional options which appear in this menu are: Language Modes Define language recognition information (for determining language mode from file name or content) and set language specific preferences. Tag Collisions How to react to multiple tags for the same name. Tags are described in Finding Declarations (ctags) . In Show All mode, all matching tags are displayed in a dialog. In Smart mode, if one of the matching tags is in the current window, that tag is chosen, without displaying the dialog. Command Shell... Set the shell used to run programs from the shell_command() macro function and from the Shell menu. This defaults to the user's login shell. Colors... Change the colors used to display text. The \"Matching (..)\" fields change the colors that matching parens, brackets and braces are flashed when the \"Show Matching (..)\" option is enabled. Note that the foreground colors for plain text, selected text, and matching paren flashing only apply when syntax highlighting is disabled. When syntax highlighting is enabled, text (even text that appears plain) will always be colored according to its highlighting style. (For information on changing syntax highlighting styles and matching patterns use see Syntax Highlighting .) Customize Menus Add/remove items from the Shell, Macro, and window background menus (see below). Customize Window Title Opens a dialog where the information to be displayed in the window's title field can be defined and tested. The dialog contains a Help button, providing further information about the options available. Searching Options for controlling the behavior of Search \u2192 Find and Search \u2192 Replace commands: Verbose Presents search results in dialog form, asks before wrapping a search back around the beginning (or end) of the file (unless Beep On Search Wrap is turned on). Wrap Around Search and Replace operations wrap around the beginning (or end) of the file. Beep On Search Wrap Beep when Search and Replace operations wrap around the beginning (or end) of the file (only if Wrap Around is turned on). Keep Dialogs Up Don't close Replace and Find boxes after searching. Default Search Style Initial setting for search type in Find and Replace dialogs. Initial setting for the scope in the Replace/Find dialog, when a selection exists. It can be either \"In Window\", \"In Selection\", or \"Smart\". \"Smart\" results in \"In Window\" if the size of the selection is smaller than 1 line, and to \"In Selection\" otherwise. Syntax Highlighting Program and configure enhanced text display for new or supported languages. (See Syntax Highlighting .) Tabbed Editing Options for controlling the tabbed interface: Open File in New Tab Open files in new tabs, else open files in new windows. Show Tab Bar Show/Hide the tab bar. Hide Tab Bar when only one Document is open Next/Prev Tabs Across Windows Suppose there are two windows with three tabs in the first window and two tabs in the second window. Enabling this option, if you are on the third tab in the first window, hitting Ctrl + PageDown would switch to the first tab in the second window (instead of switching to the first tab in the first window). Sort Tabs Alphabetically Show Tooltips Show file name and path in a tooltip when moving the mouse pointer over a tab. (See Tabbed Editing .) Terminate with Line Break on Save Some programs expect text files to end with a newline. If this option is activated, NEdit-ng will append one if not already present. Sort Open Prev. Menu Option to order File \u2192 Open Previous alphabetically, versus in order of last access. Popups Under Pointer Display pop-up dialogs centered on the current mouse position, as opposed to centered on the parent window. This generally speeds interaction, and is essential for users who set their window managers so keyboard focus follows the mouse. Auto-Scroll Near Window Top/Bottom When this option is enabled the window will automatically scroll when the cursor comes 4 lines from the top or bottom of the window (except at the beginning of the file). The number of lines can be customized with the nedit.autoScrollVPadding setting in the config.ini file. Warnings Options for controlling the popping up of warning dialogs: File Modified Externally Pop up a warning dialog when files get changed external to NEdit-ng. Check Modified File Contents If external file modification warnings are requested, also check the file contents iso. only the modification date. On Exit Ask before exiting when two or more files are open in an NEdit-ng session or before closing a window with two or more tabs. Initial Window Size Default size for new windows.","title":"Preferences &rarr; Default Settings Menu"},{"location":"29/#changing-the-display-font","text":"The font used to display text in NEdit-ng is set under Preferences \u2192 Text Font (for the current window), or Preferences \u2192 Default Settings Text Font (for future windows). NEdit-ng shows a list of the monospaced fonts that are available on your system in this dialog.","title":"Changing The Display Font"},{"location":"29/#customizing-menus","text":"You can add or change items in the Shell , Macro , and window background menus under Preferences \u2192 Default Settings \u2192 Customize Menus . When you choose one of these, you will see a dialog with a list of the current user-configurable items from the menu on the left. To change an existing item, select it from the list, and its properties will appear in the remaining fields of the dialog, where you may change them. Selecting the item New from the list allows you to enter new items in the menu. Hopefully most of the characteristics are self explanatory, but here are a few things to note: Accelerator keys are keyboard shortcuts which appear on the right hand side of the menus, and allow you avoid pulling down the menu and activate the command with a single keystroke. Enter accelerators by typing the keys exactly as you would to activate the command. Mnemonics are a single letter which should be part of the menu item name, which allow users to traverse and activate menu items by typing keys when the menu is pulled down. These are specified by placing & in the name immediately before the desired letter. For example, T&est will have e as its mnemonic. In the Shell Command field of the Shell Commands dialog, the % character expands to the name (including directory path) of the file in the window. To include a % character in the command, use %% . The Menu Entry field can contain special characters for constructing hierarchical sub-menus, and for making items which appear only in certain language modes. The right angle bracket character > creates a sub-menu. The name of the item itself should be the last element of the path formed from successive sub-menu names joined with > . Menu panes are called in to existence simply by naming them as part of a Menu Entry name. To put several items in the same sub-menu, repeat the same hierarchical sequence for each. For example, in the Macro Commands dialog, two items with menu entries: a>b>c and a>b>d would create a single sub menu under the macro menu called a , which would contain a single sub-menu, b , holding the actual items, c and d : +---++---++---+ |a >||b >||c | +---++---+|d | +---+ To qualify a menu entry with a language mode, simply add an at-sign @ at the end of the menu command, followed (no space) by a language mode name. To make a menu item which appears in several language modes, append additional @ s and language mode names. For example, an item with the menu entry: Make C Prototypes@C@C++ would appear only in C and C++ language modes, and: Make Class Template@C++ would appear only in C++ mode. Menu items with no qualification appear in all language modes. If a menu item is followed by the single language qualification @* , that item will appear only if there are no applicable language-specific items of the same name in the same submenu. For example, if you have the following three entries in the same menu: Make Prototypes@C@C++ Make Prototypes@Java Make Prototypes@* The first will be available when the language mode is C or C++, the second when the language mode is Java, and for all other language modes (including the \"Plain\" non-language mode). If the entry: Make Prototypes also exists, this will always appear, meaning that the menu will always have two \"Make Prototypes\" entries, whatever the language mode.","title":"Customizing Menus"},{"location":"29/#the-nedit-ng-autoload-files","text":"At startup time, NEdit-ng automatically reads the following files: config.ini General configuration Contains saved preferences (menu settings) in the format of a Windows ini file. style.qss An optional Qt style sheet A Qt style sheet can be used to adjust the appearance of the NEdit-ng application. theme.xml A highlighting theme file Holds the text drawing styles defined using the Preferences \u2192 Default Settings \u2192 Syntax Highlighting \u2192 Text Drawing Styles dialog. autoload.nm An optional autoload macro file May provide macro commands and definitions for NEdit-ng to execute at startup (NEdit-ng doesn't create this file automatically). history The history database A list of recently opened files, which appear under File \u2192 Open Previous . These files are normally located in $HOME/.config/nedit-ng but may be elsewhere if the Qt Generic Config Location is different.","title":"The NEdit-ng Autoload Files"},{"location":"29/#sharing-customizations-with-other-nedit-ng-users","text":"If you have written Macro or Shell menu commands, highlight patterns, or smart-indent macros that you want to share with other NEdit-ng users, you can make a file which they can load into their NEdit-ng environment. To load such a file, start NEdit-ng with the command: nedit-ng -import <file> In the new NEdit-ng session, verify that the imported patterns or macros do what you want, then select Preferences \u2192 Save Defaults . Saving incorporates the changes into the NEdit-ng preferences file, so the next time you run NEdit-ng, you will not have to import the distribution file. Loading a customization file is automated, but creating one is not. To produce a file to be imported by other users, you must make a copy of your own preferences file, and edit it, by hand, to remove everything but the few items of interest to the recipient. Leave only the individual values(s), and within those values, only the particular macro, pattern, style, etc, that you wish to exchange. For example, to share a highlighting pattern set, you would include the patterns, any new styles you added, and language mode information only if the patterns are intended to support a new language rather than updating an existing one. For example: nedit.highlightPatterns:\\ My Language:1:0{\\n\\ Comment:\"#\":\"$\"::Comment::\\n\\ Loop Header:\"^[ \\\\t]*loop:\":::Loop::\\n\\ } nedit.languageModes: My Language:.my:::::: nedit.styles: Loop:blue:Bold Values are in the format of Windows ini files, but the format of text within multiple-item values like highlight patterns, language modes, macros, styles, etc., are private to NEdit-ng. NOTE: Future versions of NEdit-ng are expected to change this internal format to be spit among several YAML files for easier user editing and management.","title":"Sharing Customizations with Other NEdit-ng Users"},{"location":"30/","text":"NEdit-ng has additional options to those provided in the Preferences menu which are set in the config.ini file. Selected Configuration Item Names The following are selected NEdit-ng configuration item names and default values for NEdit-ng options not settable via the Preferences menu (for preference value names, see your NEdit-ng config.ini file): nedit.tagFile : (not defined) This can be the name of a file, or multiple files separated by a colon : character, of the type produced by Exuberant Ctags or the Unix ctags command, which NEdit-ng will load at startup time (see Finding Declarations (ctags) ). The tag file provides a database from which NEdit-ng can automatically open files containing the definition of a particular subroutine or data type. nedit.alwaysCheckRelativeTagsSpecs : True When this value is set to True , and there are tag files specified (with the nedit.tagFile setting, see above) as relative paths, NEdit-ng will evaluate these tag value paths whenever a file is opened. All accessible tag files will be loaded at this time. When this value is False , relative path tag specifications will only be evaluated at NEdit-ng startup time. nedit.wordDelimiters : .,/\\`'!@#%^&*()-=+{}[]\":;<>? The set of characters which mark the boundaries between words. In addition to these, spaces, tabs, and newlines are always word boundaries. These boundaries take effect for the move-by-word ( Ctrl + Arrow) and select-word (double click) commands, and for doing regex searches using the \\B , < and > tokens. Note that this default value may be overridden by the setting in Preferences \u2192 Default Settings \u2192 Language Modes... . nedit.typingHidesPointer : False Setting this value to True causes the mouse pointer to be hidden when you type in the text area. As soon as the mouse pointer is moved, it will reappear. This is useful to stop the mouse pointer from obscuring text. nedit.maxPrevOpenFiles : 30 Number of files listed in File \u2192 Open Previous . Setting this to zero disables File \u2192 Open Previous and maintenance of the NEdit-ng file history file. nedit.findReplaceUsesSelection : False Controls if the Find and Replace dialogs are automatically loaded with the contents of the primary selection. nedit.stickyCaseSenseButton : True Controls if the \"Case Sensitive\" buttons in the Find and Replace dialogs and the incremental search bar maintain a separate state for literal and regular expression searches. Moreover, when set to True , by default literal searches are case insensitive and regular expression searches are case sensitive. When set to False , the \"Case Sensitive\" buttons are independent of the \"Regular Expression\" toggle. nedit.undoModifiesSelection : True By default, NEdit-ng selects any text inserted or changed through a undo/redo action. Set this value to False if you don't want your selection to be touched. nedit.autoWrapPastedText : False When Auto Newline Wrap is turned on, apply automatic wrapping (which normally only applies to typed text) to pasted text as well. nedit.heavyCursor : False For monitors with poor resolution or users who have difficulty seeing the cursor, makes the cursor in the text editing area of the window heavier and darker. nedit.autoScrollVPadding : 4 Number of lines to keep the cursor away from the top or bottom line of the window when the \"Auto-Scroll Near Window Top/Bottom\" feature is enabled. Keyboard operations that would cause the cursor to get closer than this distance cause the window to scroll up or down instead, except at the beginning of the file. Mouse operations are not affected. nedit.backlightCharTypes : 0-8,10-31,127:red;9:#dedede;32,160-255:#f0f0f0;128-159:orange (see Programming with NEdit-ng ). A string specifying character classes as ranges of ASCII values followed by the color to be used as their background colors. The format is: low[-high]{,low[-high]}:color{;low-high{,low[-high]}:color} where low and high are ASCII values. For example: 32-255:#f0f0f0;1-31,127:red;128-159:orange;9-13:#e5e5e5 nedit.focusOnRaise : False This setting determines whether new text windows and text windows that are raised, should also request the input focus. Conventionally, it is the task of the window manager to decide on which window gets the input focus. Therefore, NEdit-ng's default behaviour is not to request the input focus explicitly. nedit.forceOSConversion : True By default, NEdit-ng converts texts in MS-DOS or Mac format to an internal format using simple newlines as line dividers. This is sometimes not wanted by the user and can be prevented by setting this value to False. Note: Setting this to False would supress newlines in Mac files entirely, leaving the control character <cr> where every line feed would be. macOS uses Unix files and is not affected. Note: Setting this to False while the option 'Terminate with Line Break on Save' is active could lead to file corruption. nedit.truncSubstitution : Fail NEdit-ng has a fixed limit on substitution result string length. This value modifies the behaviour if this limit is exceeded. Possible values are Silent ( 0 , will silently fail the operation), Fail ( 1 , will fail the operation and pop up a dialog informing the user; this is the default), Warn ( 2 , pops up a dialog warning the user, offering to cancel the operation) and Ignore ( 3 , will silently conclude the operation). WARNING : Setting this to Ignore can destroy data without warning! nedit.honorSymlinks : True If set to True , NEdit-ng will open a requested file on disk even if it is a symlink pointing to a file already opened in another window. If set to False , NEdit-ng will try to detect these cases and just pop up the already opened document.","title":"Config Entries"},{"location":"30/#selected-configuration-item-names","text":"The following are selected NEdit-ng configuration item names and default values for NEdit-ng options not settable via the Preferences menu (for preference value names, see your NEdit-ng config.ini file): nedit.tagFile : (not defined) This can be the name of a file, or multiple files separated by a colon : character, of the type produced by Exuberant Ctags or the Unix ctags command, which NEdit-ng will load at startup time (see Finding Declarations (ctags) ). The tag file provides a database from which NEdit-ng can automatically open files containing the definition of a particular subroutine or data type. nedit.alwaysCheckRelativeTagsSpecs : True When this value is set to True , and there are tag files specified (with the nedit.tagFile setting, see above) as relative paths, NEdit-ng will evaluate these tag value paths whenever a file is opened. All accessible tag files will be loaded at this time. When this value is False , relative path tag specifications will only be evaluated at NEdit-ng startup time. nedit.wordDelimiters : .,/\\`'!@#%^&*()-=+{}[]\":;<>? The set of characters which mark the boundaries between words. In addition to these, spaces, tabs, and newlines are always word boundaries. These boundaries take effect for the move-by-word ( Ctrl + Arrow) and select-word (double click) commands, and for doing regex searches using the \\B , < and > tokens. Note that this default value may be overridden by the setting in Preferences \u2192 Default Settings \u2192 Language Modes... . nedit.typingHidesPointer : False Setting this value to True causes the mouse pointer to be hidden when you type in the text area. As soon as the mouse pointer is moved, it will reappear. This is useful to stop the mouse pointer from obscuring text. nedit.maxPrevOpenFiles : 30 Number of files listed in File \u2192 Open Previous . Setting this to zero disables File \u2192 Open Previous and maintenance of the NEdit-ng file history file. nedit.findReplaceUsesSelection : False Controls if the Find and Replace dialogs are automatically loaded with the contents of the primary selection. nedit.stickyCaseSenseButton : True Controls if the \"Case Sensitive\" buttons in the Find and Replace dialogs and the incremental search bar maintain a separate state for literal and regular expression searches. Moreover, when set to True , by default literal searches are case insensitive and regular expression searches are case sensitive. When set to False , the \"Case Sensitive\" buttons are independent of the \"Regular Expression\" toggle. nedit.undoModifiesSelection : True By default, NEdit-ng selects any text inserted or changed through a undo/redo action. Set this value to False if you don't want your selection to be touched. nedit.autoWrapPastedText : False When Auto Newline Wrap is turned on, apply automatic wrapping (which normally only applies to typed text) to pasted text as well. nedit.heavyCursor : False For monitors with poor resolution or users who have difficulty seeing the cursor, makes the cursor in the text editing area of the window heavier and darker. nedit.autoScrollVPadding : 4 Number of lines to keep the cursor away from the top or bottom line of the window when the \"Auto-Scroll Near Window Top/Bottom\" feature is enabled. Keyboard operations that would cause the cursor to get closer than this distance cause the window to scroll up or down instead, except at the beginning of the file. Mouse operations are not affected. nedit.backlightCharTypes : 0-8,10-31,127:red;9:#dedede;32,160-255:#f0f0f0;128-159:orange (see Programming with NEdit-ng ). A string specifying character classes as ranges of ASCII values followed by the color to be used as their background colors. The format is: low[-high]{,low[-high]}:color{;low-high{,low[-high]}:color} where low and high are ASCII values. For example: 32-255:#f0f0f0;1-31,127:red;128-159:orange;9-13:#e5e5e5 nedit.focusOnRaise : False This setting determines whether new text windows and text windows that are raised, should also request the input focus. Conventionally, it is the task of the window manager to decide on which window gets the input focus. Therefore, NEdit-ng's default behaviour is not to request the input focus explicitly. nedit.forceOSConversion : True By default, NEdit-ng converts texts in MS-DOS or Mac format to an internal format using simple newlines as line dividers. This is sometimes not wanted by the user and can be prevented by setting this value to False. Note: Setting this to False would supress newlines in Mac files entirely, leaving the control character <cr> where every line feed would be. macOS uses Unix files and is not affected. Note: Setting this to False while the option 'Terminate with Line Break on Save' is active could lead to file corruption. nedit.truncSubstitution : Fail NEdit-ng has a fixed limit on substitution result string length. This value modifies the behaviour if this limit is exceeded. Possible values are Silent ( 0 , will silently fail the operation), Fail ( 1 , will fail the operation and pop up a dialog informing the user; this is the default), Warn ( 2 , pops up a dialog warning the user, offering to cancel the operation) and Ignore ( 3 , will silently conclude the operation). WARNING : Setting this to Ignore can destroy data without warning! nedit.honorSymlinks : True If set to True , NEdit-ng will open a requested file on disk even if it is a symlink pointing to a file already opened in another window. If set to False , NEdit-ng will try to detect these cases and just pop up the already opened document.","title":"Selected Configuration Item Names"},{"location":"31/","text":"NOTE: This page is not currently applicable to NEdit-ng, once NEdit-ng has methods of changing key-bindings, this page will be updated appropriately There are several ways to change key bindings in NEdit. The easiest way to add a new key binding in NEdit is to define a macro in Preferences \u2192 Default Settings \u2192 Customize Menus \u2192 Macro Menu . However, if you want to change existing bindings or add a significant number of new key bindings you will need to do so via X resources. Before reading this section, you must understand how to set X resources (see Config Entries ). Since setting X resources is tricky, it is also helpful when working on key-binding, to set some easier-to-verify resource at the same time, as a simple check that the NEdit program is actually seeing your changes. The appres program is also very helpful in checking that the resource settings that you make, actually reach the program for which they are intended in the correct form. Key Binding in General Keyboard commands are associated with editor action routines through two separate mechanisms in NEdit. Commands which appear in pull-down menus have individual resources designating a keyboard equivalent to the menu command, called an accelerator key. Commands which do not have an associated menu item are bound to keys via the X toolkit translation mechanism. The methods for changing these two kinds of bindings are quite different. Key Binding Via Translations The most general way to bind actions to keys in NEdit is to use the translation table associated with the text widget. To add a binding to Alt+Y to insert the string \"Hi!\", for example, add lines similar to the following to your X resource file: NEdit*text.Translations: #override \\n\\ Alt<Key>y: insert_string(\"Hi!\") \\n Action Routines lists the actions available to be bound. Translation tables map key and mouse presses, window operations, and other kinds of events, to actions. The syntax for translation tables is simplified here, so you may need to refer to a book on the X window system for more detailed information. Note that accelerator resources (discussed below) override translations, and that most Ctrl+letter and Alt+letter combinations are already bound to an accelerator key. To use one of these combinations from a translation table, therefore, you must first un-bind the original menu accelerator. A resource for changing a translation table consists of a keyword; #override, #augment, or #replace; followed by lines (separated by newline characters) pairing events with actions. Events begin with modifiers, like Ctrl, Shift, or Alt, followed by the event type in \\<>. BtnDown, Btn1Down, Btn2Down, Btn1Up, Key, KeyUp are valid event types. For key presses, the event type is followed by the name of the key. You can specify a combination of events, such as a sequence of key presses, by separating them with commas. The other half of the event/action pair is a set of actions. These are separated from the event specification by a colon and from each other by spaces. Actions are names followed by parentheses, optionally containing one or more parameters separated by comas. Changing Menu Accelerator Keys The menu shortcut keys shown at the right of NEdit menu items can also be changed via X resources. Each menu item has two resources associated with it, accelerator, the event to trigger the menu item; and acceleratorText, the string shown in the menu. The form of the accelerator resource is the same as events for translation table entries discussed above, though multiple keys and other subtleties are not allowed. The resource name for a menu is the title in lower case, followed by \"Menu\", the resource name of menu item is the name in lower case, run together, with words separated by caps, and all punctuation removed. For example, to change Cut to Ctrl+X, you would add the following to your .Xdefaults file: nedit*editMenu.cut.accelerator: Ctrl<Key>x nedit*editMenu.cut.acceleratorText: Ctrl+X Accelerator keys with optional shift key modifiers, like Find..., have an additional accelerator resource with Shift appended to the name. For example: nedit*searchMenu.find.acceleratorText: [Shift]Alt+F nedit*searchMenu.find.accelerator: Alt<Key>f nedit*searchMenu.findShift.accelerator: Shift Alt<Key>f","title":"Key Bindings"},{"location":"31/#key-binding-in-general","text":"Keyboard commands are associated with editor action routines through two separate mechanisms in NEdit. Commands which appear in pull-down menus have individual resources designating a keyboard equivalent to the menu command, called an accelerator key. Commands which do not have an associated menu item are bound to keys via the X toolkit translation mechanism. The methods for changing these two kinds of bindings are quite different.","title":"Key Binding in General"},{"location":"31/#key-binding-via-translations","text":"The most general way to bind actions to keys in NEdit is to use the translation table associated with the text widget. To add a binding to Alt+Y to insert the string \"Hi!\", for example, add lines similar to the following to your X resource file: NEdit*text.Translations: #override \\n\\ Alt<Key>y: insert_string(\"Hi!\") \\n Action Routines lists the actions available to be bound. Translation tables map key and mouse presses, window operations, and other kinds of events, to actions. The syntax for translation tables is simplified here, so you may need to refer to a book on the X window system for more detailed information. Note that accelerator resources (discussed below) override translations, and that most Ctrl+letter and Alt+letter combinations are already bound to an accelerator key. To use one of these combinations from a translation table, therefore, you must first un-bind the original menu accelerator. A resource for changing a translation table consists of a keyword; #override, #augment, or #replace; followed by lines (separated by newline characters) pairing events with actions. Events begin with modifiers, like Ctrl, Shift, or Alt, followed by the event type in \\<>. BtnDown, Btn1Down, Btn2Down, Btn1Up, Key, KeyUp are valid event types. For key presses, the event type is followed by the name of the key. You can specify a combination of events, such as a sequence of key presses, by separating them with commas. The other half of the event/action pair is a set of actions. These are separated from the event specification by a colon and from each other by spaces. Actions are names followed by parentheses, optionally containing one or more parameters separated by comas.","title":"Key Binding Via Translations"},{"location":"31/#changing-menu-accelerator-keys","text":"The menu shortcut keys shown at the right of NEdit menu items can also be changed via X resources. Each menu item has two resources associated with it, accelerator, the event to trigger the menu item; and acceleratorText, the string shown in the menu. The form of the accelerator resource is the same as events for translation table entries discussed above, though multiple keys and other subtleties are not allowed. The resource name for a menu is the title in lower case, followed by \"Menu\", the resource name of menu item is the name in lower case, run together, with words separated by caps, and all punctuation removed. For example, to change Cut to Ctrl+X, you would add the following to your .Xdefaults file: nedit*editMenu.cut.accelerator: Ctrl<Key>x nedit*editMenu.cut.acceleratorText: Ctrl+X Accelerator keys with optional shift key modifiers, like Find..., have an additional accelerator resource with Shift appended to the name. For example: nedit*searchMenu.find.acceleratorText: [Shift]Alt+F nedit*searchMenu.find.accelerator: Alt<Key>f nedit*searchMenu.findShift.accelerator: Shift Alt<Key>f","title":"Changing Menu Accelerator Keys"},{"location":"32/","text":"Writing Syntax Highlighting Patterns Patterns are the mechanism by which language syntax highlighting is implemented in NEdit-ng (see Syntax Highlighting ). To create syntax highlighting patterns for a new language, or to modify existing patterns, select Preferences \u2192 Default Settings \u2192 Syntax Highlighting \u2192 Recognition Patterns . First, a word of caution. As with regular expression matching in general, it is quite possible to write patterns which are so inefficient that they essentially lock up the editor as they recursively re-examine the entire contents of the file thousands of times. With the multiplicity of patterns, the possibility of a lock-up is significantly increased in syntax highlighting. When working on highlighting patterns, be sure to save your work frequently. NEdit-ng's syntax highlighting works in real-time (as you type), and is completely programmable using standard regular expression notation. Other syntax highlighting editors often require the recognition engine to be programmed in a compiled language such as C or C++. To achieve this, NEdit-ng requires pattern writers to state self-imposed limitations on the amount of context that patterns may examine when re-parsing after a change. While the Pattern Context Requirements heading is near the end of this section, it is not optional, and must be understood before making any serious effort at pattern writing. In its simplest form, a highlight pattern consists of a regular expression to match, along with a style representing the font an color for displaying any text which matches that expression. To bold the word, \"highlight\" wherever it appears the text, the regular expression simply would be highlight . The style (selected from the drop down under the heading of Highlight Style ) determines how the text will be drawn. To bold the text, either select an existing style, such as Keyword , which bolds text, or create a new style and select it under Highlight Style . The full range of regular expression capabilities can be applied in such a pattern, with the single caveat that the expression must conclusively match or not match, within the pre-defined context distance (as discussed below under Pattern Context Requirements ). To match longer ranges of text, particularly any constructs which exceed the requested context, you must use a pattern which highlights text between a starting and ending regular expression match. To do so, select Highlight text between starting and ending REs under Matching , and enter both a starting and ending regular expression. For example, to highlight everything between double quotes, you would enter a double quote character in both the starting and ending regular expression fields. Patterns with both a beginning and ending expression span all characters between the two expressions, including newlines. Again, the limitation for automatic parsing to operate properly is that both expressions must match within the context distance stated for the pattern set. With the ability to span large distances, comes the responsibility to recover when things go wrong. Remember that syntax highlighting is called upon to parse incorrect or incomplete syntax as often as correct syntax. To stop a pattern short of matching its end expression, you can specify an error expression, which stops the pattern from gobbling up more than it should. For example, if the text between double quotes shouldn't contain newlines, the error expression might be $ . As with both starting and ending expressions, error expressions must also match within the requested context distance. Coloring Sub-Expressions It is also possible to color areas of text within a regular expression match. A pattern of this type associates a style with sub-expressions references of the parent pattern (as used in regular expression substitution patterns, see Regular Expressions ). Sub-expressions of both the starting and ending patterns may be colored. For example, if the parent pattern has a starting expression \\< , and end expression \\> , (for highlighting all of the text contained within angle brackets), a sub-pattern using & in both the starting and ending expression fields could color the brackets differently from the intervening text. In some cases, there can be interference between coloring sub-patterns and hierarchical sub-patterns (discussed next). How this is resolved, is explained below. Hierarchical Patterns A hierarchical sub-pattern, is identical to a top level pattern, but is invoked only between the starting and ending expression matches of its parent pattern or, in case the parent pattern consists of a single expression, inside the text area matching that expression. Like the sub-expression coloring patterns discussed above, it is associated with a parent pattern using the Parent Pattern field in the pattern specification. The matching behaviour for sub-patterns is slightly different, depending on whether the parent pattern consists of a single expression or has both a starting and an ending expression. In case the parent pattern consists of a single expression, and the syntax highlighting parser finds a match for that expression, sub-patterns are matched between the start and the end of the parent match. Sub-patterns cannot extend beyond the boundaries of the parent's match nor can they affect those boundaries (the latter can happen for starting/ending parent patterns, see below). Note that sub-patterns can peek beyond the parent's matching boundaries by means of look-ahead or look-behind expressions. In case the parent pattern is a starting/ending style pattern, after the start expression of the parent pattern matches, the syntax highlighting parser searches for either the parent's end pattern or a matching sub-pattern. When a sub-pattern matches, control is not returned to the parent pattern until the entire sub-pattern has been parsed, regardless of whether the parent's end pattern appears in the text matched by the sub-pattern. In this way, matching of the parent's ending pattern can be postponed, in contrast to the case where the parent pattern consists of a single expression. Note that, in this case, parsing of sub-patterns starts after the match of the parent pattern's starting expression, also in contrast to the single-expression case. The most common use for this capability is for coloring sub-structure of language constructs (smaller patterns embedded in larger patterns). Hierarchical patterns can also simplify parsing by having sub-patterns \"hide\" special syntax from parent patterns, such as special escape sequences or internal comments. There is no depth limit in nesting hierarchical sub-patterns, but beyond the third level of nesting, automatic re-parsing will sometimes have to re-parse more than the requested context distance to guarantee a correct parse (which can slow down the maximum rate at which the user can type if large sections of text are matched only by deeply nested patterns). While this is obviously not a complete hierarchical language parser it is still useful in many text coloring situations. As a pattern writer, your goal is not to completely cover the language syntax, but to generate colorings that are useful to the programmer. Simpler patterns are usually more efficient and also more robust when applied to incorrect code. Note that in case of a single-expression parent pattern, there is a potential for conflicts between coloring-only sub-patterns and hierarchical sub-patterns (which cannot happen for starting/ending type of patterns, because sub-patterns are matched between the starting and ending pattern (not included)). Due to the different nature of these two kinds of sub-patterns, it is technically infeasible to follow the standard matching precedence rules, where a sub-pattern has precedence over the sub-patterns following it. Instead, coloring-only sub-patterns are always colored last, ie., they may override the coloring for overlapping sibling sub-patterns in the overlapping parts of the matches. Deferred (Pass-2) Parsing NEdit-ng does pattern matching for syntax highlighting in two passes. The first pass is applied to the entire file when syntax highlighting is first turned on, and to new ranges of text when they are initially read or pasted in. The second pass is applied only as needed when text is exposed (scrolled in to view). If you have a particularly complex set of patterns, and parsing is beginning to add a noticeable delay to opening files or operations which change large regions of text, you can defer some of that parsing from startup time, to when it is actually needed for viewing the text. Deferred parsing can only be used with single expression patterns, or begin/end patterns which match entirely within the requested context distance. To defer the parsing of a pattern to when the text is exposed, click on the Pass-2 pattern type button in the highlight patterns dialog. Sometimes a pattern can't be deferred, not because of context requirements, but because it must run concurrently with pass-1 (non-deferred) patterns. If they didn't run concurrently, a pass-1 pattern might incorrectly match some of the characters which would normally be hidden inside of a sequence matched by the deferred pattern. For example, C has character constants enclosed in single quotes. These typically do not cross line boundaries, meaning they can be parsed entirely within the context distance of the C pattern set and should be good candidates for deferred parsing. However, they can't be deferred because they can contain sequences of characters which can trigger pass-one patterns. Specifically, the sequence, \\\" , contains a double quote character, which would be matched by the string pattern and interpreted as introducing a string. Pattern Context Requirements The context requirements of a pattern set state how much additional text around any change must be examined to guarantee that the patterns will match what they are intended to match. Context requirements are a promise by NEdit-ng to the pattern writer, that the regular expressions in his/her patterns will be matched against at least <line context> lines and <character context> characters, around any modified text. Combining line and character requirements guarantee that both will be met. Automatic re-parsing happens on every keystroke , so the amount of context which must be examined is very critical to typing efficiency. The more complicated your patterns, the more critical the context becomes. To cover all of the keywords in a typical language, without affecting the maximum rate at which users can enter text, you may be limited to just a few lines and/or a few hundred characters of context. The default context distance is 1 line, with no minimum character requirement. There are several benefits to sticking with this default. One is simply that it is easy to understand and to comply with. Regular expression notation is designed around single line matching. To span lines in a regular expression, you must explicitly mention the newline character \\n , and matches which are restricted to a single line are virtually immune to lock-ups. Also, if you can code your patterns to work within a single line of context, without an additional character-range context requirement, the parser can take advantage the fact that patterns don't cross line boundaries, and nearly double its efficiency over a one-line and 1-character context requirement. (In a single line context, you are allowed to match newlines, but only as the first and/or last character.)","title":"Highlighting Patterns"},{"location":"32/#writing-syntax-highlighting-patterns","text":"Patterns are the mechanism by which language syntax highlighting is implemented in NEdit-ng (see Syntax Highlighting ). To create syntax highlighting patterns for a new language, or to modify existing patterns, select Preferences \u2192 Default Settings \u2192 Syntax Highlighting \u2192 Recognition Patterns . First, a word of caution. As with regular expression matching in general, it is quite possible to write patterns which are so inefficient that they essentially lock up the editor as they recursively re-examine the entire contents of the file thousands of times. With the multiplicity of patterns, the possibility of a lock-up is significantly increased in syntax highlighting. When working on highlighting patterns, be sure to save your work frequently. NEdit-ng's syntax highlighting works in real-time (as you type), and is completely programmable using standard regular expression notation. Other syntax highlighting editors often require the recognition engine to be programmed in a compiled language such as C or C++. To achieve this, NEdit-ng requires pattern writers to state self-imposed limitations on the amount of context that patterns may examine when re-parsing after a change. While the Pattern Context Requirements heading is near the end of this section, it is not optional, and must be understood before making any serious effort at pattern writing. In its simplest form, a highlight pattern consists of a regular expression to match, along with a style representing the font an color for displaying any text which matches that expression. To bold the word, \"highlight\" wherever it appears the text, the regular expression simply would be highlight . The style (selected from the drop down under the heading of Highlight Style ) determines how the text will be drawn. To bold the text, either select an existing style, such as Keyword , which bolds text, or create a new style and select it under Highlight Style . The full range of regular expression capabilities can be applied in such a pattern, with the single caveat that the expression must conclusively match or not match, within the pre-defined context distance (as discussed below under Pattern Context Requirements ). To match longer ranges of text, particularly any constructs which exceed the requested context, you must use a pattern which highlights text between a starting and ending regular expression match. To do so, select Highlight text between starting and ending REs under Matching , and enter both a starting and ending regular expression. For example, to highlight everything between double quotes, you would enter a double quote character in both the starting and ending regular expression fields. Patterns with both a beginning and ending expression span all characters between the two expressions, including newlines. Again, the limitation for automatic parsing to operate properly is that both expressions must match within the context distance stated for the pattern set. With the ability to span large distances, comes the responsibility to recover when things go wrong. Remember that syntax highlighting is called upon to parse incorrect or incomplete syntax as often as correct syntax. To stop a pattern short of matching its end expression, you can specify an error expression, which stops the pattern from gobbling up more than it should. For example, if the text between double quotes shouldn't contain newlines, the error expression might be $ . As with both starting and ending expressions, error expressions must also match within the requested context distance.","title":"Writing Syntax Highlighting Patterns"},{"location":"32/#coloring-sub-expressions","text":"It is also possible to color areas of text within a regular expression match. A pattern of this type associates a style with sub-expressions references of the parent pattern (as used in regular expression substitution patterns, see Regular Expressions ). Sub-expressions of both the starting and ending patterns may be colored. For example, if the parent pattern has a starting expression \\< , and end expression \\> , (for highlighting all of the text contained within angle brackets), a sub-pattern using & in both the starting and ending expression fields could color the brackets differently from the intervening text. In some cases, there can be interference between coloring sub-patterns and hierarchical sub-patterns (discussed next). How this is resolved, is explained below.","title":"Coloring Sub-Expressions"},{"location":"32/#hierarchical-patterns","text":"A hierarchical sub-pattern, is identical to a top level pattern, but is invoked only between the starting and ending expression matches of its parent pattern or, in case the parent pattern consists of a single expression, inside the text area matching that expression. Like the sub-expression coloring patterns discussed above, it is associated with a parent pattern using the Parent Pattern field in the pattern specification. The matching behaviour for sub-patterns is slightly different, depending on whether the parent pattern consists of a single expression or has both a starting and an ending expression. In case the parent pattern consists of a single expression, and the syntax highlighting parser finds a match for that expression, sub-patterns are matched between the start and the end of the parent match. Sub-patterns cannot extend beyond the boundaries of the parent's match nor can they affect those boundaries (the latter can happen for starting/ending parent patterns, see below). Note that sub-patterns can peek beyond the parent's matching boundaries by means of look-ahead or look-behind expressions. In case the parent pattern is a starting/ending style pattern, after the start expression of the parent pattern matches, the syntax highlighting parser searches for either the parent's end pattern or a matching sub-pattern. When a sub-pattern matches, control is not returned to the parent pattern until the entire sub-pattern has been parsed, regardless of whether the parent's end pattern appears in the text matched by the sub-pattern. In this way, matching of the parent's ending pattern can be postponed, in contrast to the case where the parent pattern consists of a single expression. Note that, in this case, parsing of sub-patterns starts after the match of the parent pattern's starting expression, also in contrast to the single-expression case. The most common use for this capability is for coloring sub-structure of language constructs (smaller patterns embedded in larger patterns). Hierarchical patterns can also simplify parsing by having sub-patterns \"hide\" special syntax from parent patterns, such as special escape sequences or internal comments. There is no depth limit in nesting hierarchical sub-patterns, but beyond the third level of nesting, automatic re-parsing will sometimes have to re-parse more than the requested context distance to guarantee a correct parse (which can slow down the maximum rate at which the user can type if large sections of text are matched only by deeply nested patterns). While this is obviously not a complete hierarchical language parser it is still useful in many text coloring situations. As a pattern writer, your goal is not to completely cover the language syntax, but to generate colorings that are useful to the programmer. Simpler patterns are usually more efficient and also more robust when applied to incorrect code. Note that in case of a single-expression parent pattern, there is a potential for conflicts between coloring-only sub-patterns and hierarchical sub-patterns (which cannot happen for starting/ending type of patterns, because sub-patterns are matched between the starting and ending pattern (not included)). Due to the different nature of these two kinds of sub-patterns, it is technically infeasible to follow the standard matching precedence rules, where a sub-pattern has precedence over the sub-patterns following it. Instead, coloring-only sub-patterns are always colored last, ie., they may override the coloring for overlapping sibling sub-patterns in the overlapping parts of the matches.","title":"Hierarchical Patterns"},{"location":"32/#deferred-pass-2-parsing","text":"NEdit-ng does pattern matching for syntax highlighting in two passes. The first pass is applied to the entire file when syntax highlighting is first turned on, and to new ranges of text when they are initially read or pasted in. The second pass is applied only as needed when text is exposed (scrolled in to view). If you have a particularly complex set of patterns, and parsing is beginning to add a noticeable delay to opening files or operations which change large regions of text, you can defer some of that parsing from startup time, to when it is actually needed for viewing the text. Deferred parsing can only be used with single expression patterns, or begin/end patterns which match entirely within the requested context distance. To defer the parsing of a pattern to when the text is exposed, click on the Pass-2 pattern type button in the highlight patterns dialog. Sometimes a pattern can't be deferred, not because of context requirements, but because it must run concurrently with pass-1 (non-deferred) patterns. If they didn't run concurrently, a pass-1 pattern might incorrectly match some of the characters which would normally be hidden inside of a sequence matched by the deferred pattern. For example, C has character constants enclosed in single quotes. These typically do not cross line boundaries, meaning they can be parsed entirely within the context distance of the C pattern set and should be good candidates for deferred parsing. However, they can't be deferred because they can contain sequences of characters which can trigger pass-one patterns. Specifically, the sequence, \\\" , contains a double quote character, which would be matched by the string pattern and interpreted as introducing a string.","title":"Deferred (Pass-2) Parsing"},{"location":"32/#pattern-context-requirements","text":"The context requirements of a pattern set state how much additional text around any change must be examined to guarantee that the patterns will match what they are intended to match. Context requirements are a promise by NEdit-ng to the pattern writer, that the regular expressions in his/her patterns will be matched against at least <line context> lines and <character context> characters, around any modified text. Combining line and character requirements guarantee that both will be met. Automatic re-parsing happens on every keystroke , so the amount of context which must be examined is very critical to typing efficiency. The more complicated your patterns, the more critical the context becomes. To cover all of the keywords in a typical language, without affecting the maximum rate at which users can enter text, you may be limited to just a few lines and/or a few hundred characters of context. The default context distance is 1 line, with no minimum character requirement. There are several benefits to sticking with this default. One is simply that it is easy to understand and to comply with. Regular expression notation is designed around single line matching. To span lines in a regular expression, you must explicitly mention the newline character \\n , and matches which are restricted to a single line are virtually immune to lock-ups. Also, if you can code your patterns to work within a single line of context, without an additional character-range context requirement, the parser can take advantage the fact that patterns don't cross line boundaries, and nearly double its efficiency over a one-line and 1-character context requirement. (In a single line context, you are allowed to match newlines, but only as the first and/or last character.)","title":"Pattern Context Requirements"},{"location":"33/","text":"Smart indent macros can be written for any language, but are usually more difficult to write than highlighting patterns. A good place to start, of course, is to look at the existing macros for C and C++. Smart indent macros for a language mode consist of standard NEdit-ng macro language code attached to any or all of the following three activation conditions: When smart indent is first turned on for a text window containing code of the language. When a newline is typed and smart indent is expected. after any character is typed. To attach macro code to any of these code \"hooks\", enter it in the appropriate section in the Preferences \u2192 Default Settings \u2192 Auto Indent \u2192 Program Smart Indent dialog. Typically most of the code should go in the initialization section, because that is the appropriate place for subroutine definitions, and smart indent macros are complicated enough that you are not likely to want to write them as one monolithic run of code. You may also put code in the Common/Shared Initialization section (accessible through the button in the upper left corner of the dialog). Unfortunately, since the C/C++ macros also reside in the common/shared section, when you add code there, you run some risk of missing out on future upgrades to these macros, because your changes will override the built-in defaults. The newline() macro is invoked after the user types a newline, but before the newline is entered in the buffer. It takes a single argument $1 which is the position at which the newline will be inserted. It must return the number of characters of indentation the line should have, or -1 . A return value of -1 means to do a standard auto-indent. You must supply a newline macro, but the code: return -1 (auto-indent), or return 0 (no indent) is sufficient. The type-in() macro takes two arguments, and does not return a value. $1 is the insert position, and $2 is the character just typed. It also is invoked before the character is inserted into the buffer. You can do just about anything here, but keep in mind that this macro is executed for every keystroke typed, so if you try to get too fancy, you may degrade performance.","title":"Smart Indent Macros"},{"location":"34/","text":"nedit-ng [-read] [-create] [-line n | +n] [-server] [-do command] [-tags file] [-tabs n] [-wrap] [-nowrap] [-autowrap] [-autoindent] [-noautoindent] [-autosave] [-noautosave] [-rows n] [-columns n] [-font font] [-lm languagemode] [-geometry geometry] [-iconic] [-noiconic] [-svrname name] [-import file] [-tabbed] [-untabbed] [-group] [-V|-version] [-h|-help] [--] [file...] -read Open the file Read Only regardless of the actual file protection. -create Don't warn about file creation when a file doesn't exist. -line n (or +n ) Go to line number n in the file following this switch. -server Designate this session as an NEdit-ng server, for processing commands from the nc-ng program. nc-ng can be used to interface NEdit-ng to code development environments, mailers, etc., or just as a quick way to open files from the shell command line without starting a new NEdit-ng session. -do command Execute an NEdit-ng macro or action on the file following the -do argument on the command line. -do is particularly useful from the nc-ng program, where nc-ng -do can remotely execute commands in an NEdit-ng -server session. -tags file Load a file of directions for finding definitions of program subroutines and data objects. The file must be of the format generated by Exuberant Ctags, or the standard Unix ctags command. -tabs n Set tab stops every n characters. -wrap , -nowrap Wrap long lines at the right edge of the window rather than continuing them past it. (Continuous Wrap mode) -autowrap , -noautowrap Wrap long lines when the cursor reaches the right edge of the window by inserting newlines at word boundaries. (Auto Newline Wrap mode) -autoindent , -noautoindent Maintain a running indent. -autosave , -noautosave Maintain a backup copy of the file being edited under the name ~filename . -rows n Default height in characters for an editing window. -columns n Default width in characters for an editing window. -font font (or -fn font ) Font for text being edited. -lm languagemode Initial language mode used for editing succeeding files. -geometry geometry (or -g geometry ) The initial size and/or location of editor windows. The argument geometry has the form: [<width>x<height>][+|-][<xoffset>[+|-]<yoffset>] where <width> and <height> are the desired width and height of the window, and <xoffset> and <yoffset> are the distance from the edge of the screen to the window, + for top or left, - for bottom or right. -geometry can be specified for individual files on the command line. -iconic , -noiconic Initial window state for succeeding files. -tabbed Open all subsequent files in new tabs. Resets -group option. -untabbed Open all subsequent files in new windows. Resets -group option. Note that this only works on subsequent files in this command and does not put NEdit-ng in tab-less mode. -group Open all subsequent files as tabs in a new window. -svrname name When starting NEdit-ng in server mode, name the server, such that it responds to requests only when nc-ng is given a corresponding -svrname argument. By naming servers, you can run several simultaneously, and direct files and commands specifically to any one. Specifying a non-empty name automatically designates this session as an NEdit-ng server, as though -server were specified. -import file Loads an additional preferences file on top of the existing defaults saved in your preferences file. To incorporate macros, language modes, and highlight patterns and styles written by other users, run NEdit-ng with -import <file> , then re-save your preferences file with Preferences \u2192 Save Defaults . -version -V Prints out the NEdit-ng version information. -help -h Prints out the NEdit-ng command line help. -- Treats all subsequent arguments as file names, even if they start with a dash. This is so NEdit-ng can access files that begin with the dash character.","title":"NEdit-ng Command Line"},{"location":"35/","text":"NEdit-ng can be operated on its own, or as a two-part client/server application. Client/server mode is useful for integrating NEdit-ng with software development environments, mailers, and other programs; or just as a quick way to open files from the shell command line without starting a new NEdit-ng session. To run NEdit-ng in server mode, type: nedit-ng -server NEdit-ng can also be started in server mode via the NEdit-ng Client program ( nc-ng ) when no servers are available. The nc-ng program, which is distributed along with NEdit-ng, sends commands to an NEdit-ng server to open files or execute editor actions. It can also be used on files that are already opened. Listing a file on the nc-ng command line means: Open it if it is not already open and bring the window to the front. nc-ng supports the following command line options: nc-ng [-read] [-create] [-line n | +n] [-do command] [-lm languagemode] [-svrname name] [-svrcmd command] [-ask] [-noask] [-timeout seconds] [-geometry geometry | -g geometry] [-icon | -iconic] [-tabbed] [-untabbed] [-group] [-wait] [-V | -version] [--] [file...] -read Open the file read-only regardless of its actual permissions. There is no effect if the file is already open. -create Don't warn about file creation when a file doesn't exist. -line n , +n Go to line number n . This will also affect files which are already open. -do command Execute an NEdit-ng macro or action on the file following the -do argument on the command line. If you use this command without a filename, nc-ng would randomly choose one window to focus and execute the macro in. -lm languagemode Initial language mode used. -svrname name Explicitly instructs nc-ng which server to connect to, an instance of nedit-ng with a corresponding -svrname argument. By naming servers, you can run several simultaneously, and direct files and commands specifically to any one. -svrcmd command The command which nc-ng uses to start an NEdit-ng server. Defaults to nedit-ng -server . -ask , -noask Instructs nc-ng to automatically start a server if one is not available. -timeout seconds Basic time-out period used in communication with an NEdit-ng server. The default is 10 seconds. Under rare conditions (such as a slow connection), it may be necessary to increase the time-out period. In most cases, the default is fine. -geometry geometry , -g geometry The initial size and/or location of editor windows. See NEdit-ng Command Line for details. -icon , -iconic Initial window state. -tabbed Open all subsequent files in new tabs. Resets -group option. -untabbed Open all subsequent files in new windows. Resets -group option. -group Open all subsequent files as tabs in a new window. -wait Instructs nc-ng not to return to the shell until all files given are closed. Normally, nc-ng returns once the files given in its command line are opened by the server. When this option is given, nc-ng returns only after the last file given in this call is closed. Note that this option affects all files in the command line, not only the ones following this option. Note that nc-ng will wait for all files given in the command line, even if the files were already opened. -version , -V Prints nc-ng 's version and build information. Command Line Arguments In typical Unix style, arguments affect the files which follow them on the command line, for example: Incorrect : nc-ng file.c -line 25 Correct : nc-ng -line 25 file.c -read , -create , and -line affect all of the files which follow them on the command line. The -do macro is executed only once, on the next file on the line. -do without a file following it on the command line, executes the macro on the first available window (presumably when you give a -do command without a corresponding file or window, you intend it to do something independent of the window in which it happens to execute). The -wait option affects all files named in the command line. Multiple Servers Sometimes it is useful to have more than one NEdit-ng server running, for example to keep mail and programming work separate. The option, -svrname , to both nedit-ng and nc-ng , allows you to start, and communicate with, separate named servers. A named server responds only to requests with the corresponding -svrname argument. Communication Communication between nc-ng and nedit-ng is done through a local socket. nc-ng uses the DISPLAY environment variable, the machine name and your user name to find the appropriate server. The command which nc-ng uses to start an NEdit-ng server is settable using the -svrCommand argument, by default nedit-ng -server .","title":"Client/Server Mode"},{"location":"35/#command-line-arguments","text":"In typical Unix style, arguments affect the files which follow them on the command line, for example: Incorrect : nc-ng file.c -line 25 Correct : nc-ng -line 25 file.c -read , -create , and -line affect all of the files which follow them on the command line. The -do macro is executed only once, on the next file on the line. -do without a file following it on the command line, executes the macro on the first available window (presumably when you give a -do command without a corresponding file or window, you intend it to do something independent of the window in which it happens to execute). The -wait option affects all files named in the command line.","title":"Command Line Arguments"},{"location":"35/#multiple-servers","text":"Sometimes it is useful to have more than one NEdit-ng server running, for example to keep mail and programming work separate. The option, -svrname , to both nedit-ng and nc-ng , allows you to start, and communicate with, separate named servers. A named server responds only to requests with the corresponding -svrname argument.","title":"Multiple Servers"},{"location":"35/#communication","text":"Communication between nc-ng and nedit-ng is done through a local socket. nc-ng uses the DISPLAY environment variable, the machine name and your user name to find the appropriate server. The command which nc-ng uses to start an NEdit-ng server is settable using the -svrCommand argument, by default nedit-ng -server .","title":"Communication"},{"location":"36/","text":"If a system crash, network failure, X server crash, or program error should happen while you are editing a file, you can still recover most of your work. NEdit-ng maintains a backup file which it updates periodically (every 8 editing operations or 80 characters typed). This file has the same name as the file that you are editing, but with the character ~ (tilde) prefixed to the name. To recover a file after a crash, simply rename the file to remove the tilde character, replacing the older version of the file. (Because several of the Unix shells consider the tilde to be a special character, you may have to prefix the character with a \\ (backslash) when you move or delete an NEdit-ng backup file.) Example, to recover the file called \"help.c\" on Unix type the command: mv ~help.c help.c A minor caveat, is that if the file you were editing was in MS-DOS format, the backup file will be in Unix format, and you will need to open the backup file in NEdit-ng and change the file format back to MS-DOS via the File \u2192 Save As... dialog (or use the Unix unix2dos command outside of NEdit-ng).","title":"Crash Recovery"},{"location":"38/","text":"GNU GENERAL PUBLIC LICENSE Version 2, June 1991 Copyright (C) 1989, 1991 Free Software Foundation, Inc. 675 Mass Ave, Cambridge, MA 02139, USA. Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed. Preamble The licenses for most software are designed to take away your freedom to share and change it. By contrast, the GNU General Public License is intended to guarantee your freedom to share and change free software--to make sure the software is free for all its users. This General Public License applies to most of the Free Software Foundation's software and to any other program whose authors commit to using it. (Some other Free Software Foundation software is covered by the GNU Library General Public License instead.) You can apply it to your programs, too. When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for this service if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs; and that you know you can do these things. To protect your rights, we need to make restrictions that forbid anyone to deny you these rights or to ask you to surrender the rights. These restrictions translate to certain responsibilities for you if you distribute copies of the software, or if you modify it. For example, if you distribute copies of such a program, whether gratis or for a fee, you must give the recipients all the rights that you have. You must make sure that they, too, receive or can get the source code. And you must show them these terms so they know their rights. We protect your rights with two steps: (1) copyright the software, and (2) offer you this license which gives you legal permission to copy, distribute and/or modify the software. Also, for each author's protection and ours, we want to make certain that everyone understands that there is no warranty for this free software. If the software is modified by someone else and passed on, we want its recipients to know that what they have is not the original, so that any problems introduced by others will not reflect on the original authors' reputations. Finally, any free program is threatened constantly by software patents. We wish to avoid the danger that redistributors of a free program will individually obtain patent licenses, in effect making the program proprietary. To prevent this, we have made it clear that any patent must be licensed for everyone's free use or not licensed at all. The precise terms and conditions for copying, distribution and modification follow. GNU GENERAL PUBLIC LICENSE TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION 0. This License applies to any program or other work which contains a notice placed by the copyright holder saying it may be distributed under the terms of this General Public License. The \"Program\", below, refers to any such program or work, and a \"work based on the Program\" means either the Program or any derivative work under copyright law: that is to say, a work containing the Program or a portion of it, either verbatim or with modifications and/or translated into another language. (Hereinafter, translation is included without limitation in the term \"modification\".) Each licensee is addressed as \"you\". Activities other than copying, distribution and modification are not covered by this License; they are outside its scope. The act of running the Program is not restricted, and the output from the Program is covered only if its contents constitute a work based on the Program (independent of having been made by running the Program). Whether that is true depends on what the Program does. 1. You may copy and distribute verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice and disclaimer of warranty; keep intact all the notices that refer to this License and to the absence of any warranty; and give any other recipients of the Program a copy of this License along with the Program. You may charge a fee for the physical act of transferring a copy, and you may at your option offer warranty protection in exchange for a fee. 2. You may modify your copy or copies of the Program or any portion of it, thus forming a work based on the Program, and copy and distribute such modifications or work under the terms of Section 1 above, provided that you also meet all of these conditions: a) You must cause the modified files to carry prominent notices stating that you changed the files and the date of any change. b) You must cause any work that you distribute or publish, that in whole or in part contains or is derived from the Program or any part thereof, to be licensed as a whole at no charge to all third parties under the terms of this License. c) If the modified program normally reads commands interactively when run, you must cause it, when started running for such interactive use in the most ordinary way, to print or display an announcement including an appropriate copyright notice and a notice that there is no warranty (or else, saying that you provide a warranty) and that users may redistribute the program under these conditions, and telling the user how to view a copy of this License. (Exception: if the Program itself is interactive but does not normally print such an announcement, your work based on the Program is not required to print an announcement.) These requirements apply to the modified work as a whole. If identifiable sections of that work are not derived from the Program, and can be reasonably considered independent and separate works in themselves, then this License, and its terms, do not apply to those sections when you distribute them as separate works. But when you distribute the same sections as part of a whole which is a work based on the Program, the distribution of the whole must be on the terms of this License, whose permissions for other licensees extend to the entire whole, and thus to each and every part regardless of who wrote it. Thus, it is not the intent of this section to claim rights or contest your rights to work written entirely by you; rather, the intent is to exercise the right to control the distribution of derivative or collective works based on the Program. In addition, mere aggregation of another work not based on the Program with the Program (or with a work based on the Program) on a volume of a storage or distribution medium does not bring the other work under the scope of this License. 3. You may copy and distribute the Program (or a work based on it, under Section 2) in object code or executable form under the terms of Sections 1 and 2 above provided that you also do one of the following: a) Accompany it with the complete corresponding machine-readable source code, which must be distributed under the terms of Sections 1 and 2 above on a medium customarily used for software interchange; or, b) Accompany it with a written offer, valid for at least three years, to give any third party, for a charge no more than your cost of physically performing source distribution, a complete machine-readable copy of the corresponding source code, to be distributed under the terms of Sections 1 and 2 above on a medium customarily used for software interchange; or, c) Accompany it with the information you received as to the offer to distribute corresponding source code. (This alternative is allowed only for noncommercial distribution and only if you received the program in object code or executable form with such an offer, in accord with Subsection b above.) The source code for a work means the preferred form of the work for making modifications to it. For an executable work, complete source code means all the source code for all modules it contains, plus any associated interface definition files, plus the scripts used to control compilation and installation of the executable. However, as a special exception, the source code distributed need not include anything that is normally distributed (in either source or binary form) with the major components (compiler, kernel, and so on) of the operating system on which the executable runs, unless that component itself accompanies the executable. If distribution of executable or object code is made by offering access to copy from a designated place, then offering equivalent access to copy the source code from the same place counts as distribution of the source code, even though third parties are not compelled to copy the source along with the object code. 4. You may not copy, modify, sublicense, or distribute the Program except as expressly provided under this License. Any attempt otherwise to copy, modify, sublicense or distribute the Program is void, and will automatically terminate your rights under this License. However, parties who have received copies, or rights, from you under this License will not have their licenses terminated so long as such parties remain in full compliance. 5. You are not required to accept this License, since you have not signed it. However, nothing else grants you permission to modify or distribute the Program or its derivative works. These actions are prohibited by law if you do not accept this License. Therefore, by modifying or distributing the Program (or any work based on the Program), you indicate your acceptance of this License to do so, and all its terms and conditions for copying, distributing or modifying the Program or works based on it. 6. Each time you redistribute the Program (or any work based on the Program), the recipient automatically receives a license from the original licensor to copy, distribute or modify the Program subject to these terms and conditions. You may not impose any further restrictions on the recipients' exercise of the rights granted herein. You are not responsible for enforcing compliance by third parties to this License. 7. If, as a consequence of a court judgment or allegation of patent infringement or for any other reason (not limited to patent issues), conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot distribute so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not distribute the Program at all. For example, if a patent license would not permit royalty-free redistribution of the Program by all those who receive copies directly or indirectly through you, then the only way you could satisfy both it and this License would be to refrain entirely from distribution of the Program. If any portion of this section is held invalid or unenforceable under any particular circumstance, the balance of the section is intended to apply and the section as a whole is intended to apply in other circumstances. It is not the purpose of this section to induce you to infringe any patents or other property right claims or to contest validity of any such claims; this section has the sole purpose of protecting the integrity of the free software distribution system, which is implemented by public license practices. Many people have made generous contributions to the wide range of software distributed through that system in reliance on consistent application of that system; it is up to the author/donor to decide if he or she is willing to distribute software through any other system and a licensee cannot impose that choice. This section is intended to make thoroughly clear what is believed to be a consequence of the rest of this License. 8. If the distribution and/or use of the Program is restricted in certain countries either by patents or by copyrighted interfaces, the original copyright holder who places the Program under this License may add an explicit geographical distribution limitation excluding those countries, so that distribution is permitted only in or among countries not thus excluded. In such case, this License incorporates the limitation as if written in the body of this License. 9. The Free Software Foundation may publish revised and/or new versions of the General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Program specifies a version number of this License which applies to it and \"any later version\", you have the option of following the terms and conditions either of that version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of this License, you may choose any version ever published by the Free Software Foundation. 10. If you wish to incorporate parts of the Program into other free programs whose distribution conditions are different, write to the author to ask for permission. For software which is copyrighted by the Free Software Foundation, write to the Free Software Foundation; we sometimes make exceptions for this. Our decision will be guided by the two goals of preserving the free status of all derivatives of our free software and of promoting the sharing and reuse of software generally. NO WARRANTY 11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION. 12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. END OF TERMS AND CONDITIONS","title":"GNU General Public License"},{"location":"40/","text":"Solutions to Common Problems For a much more comprehensive list of common problems and solutions, see the NEdit WIKI at: https://github.com/eteran/nedit-ng/wiki/ . Find Again and Replace Again don't continue in the same direction as the original Find or Replace. Find Again and Replace Again don't use the direction of the original search. Shift controls the direction: Ctrl + G means forward, Shift + Ctrl + G means backward. Preferences specified in the Preferences menu don't seem to get saved when I select Preferences \u2192 Save Defaults. NEdit has two kinds of preferences: per-window preferences, in the Preferences menu. default settings for preferences in newly created windows, in Preferences \u2192 Default Settings . Per-window preferences are not saved by Save Defaults , only Default Settings . NEdit performs poorly on very large files. Turn off Incremental Backup . With Incremental Backup on, NEdit periodically writes a full copy of the file to disk. Commands added to the Shell Commands menu (Unix only) don't output anything until they are finished executing. If the command output is directed to a dialog, or the input is from a selection, output is collected together and held until the command completes. De-select both of the options and the output will be shown incrementally as the command executes. Known Defects Below is the list of known defects which affect NEdit-ng. All Versions DEFECT Operations between rectangular selections on overlapping lines do nothing. Work Around None. These operations are very complicated and rarely used. DEFECT Cut and Paste menu items fail, or possibly crash, for very large (multi-megabyte) selections. Work Around Use selection copy (middle mouse button click) for transferring larger quantities of data. Cut and Paste save the copied text in server memory, which is usually limited. Reporting Defects Submit bugs through the web at: https://github.com/eteran/nedit-ng/issues","title":"Problems/Defects"},{"location":"40/#solutions-to-common-problems","text":"For a much more comprehensive list of common problems and solutions, see the NEdit WIKI at: https://github.com/eteran/nedit-ng/wiki/ . Find Again and Replace Again don't continue in the same direction as the original Find or Replace. Find Again and Replace Again don't use the direction of the original search. Shift controls the direction: Ctrl + G means forward, Shift + Ctrl + G means backward. Preferences specified in the Preferences menu don't seem to get saved when I select Preferences \u2192 Save Defaults. NEdit has two kinds of preferences: per-window preferences, in the Preferences menu. default settings for preferences in newly created windows, in Preferences \u2192 Default Settings . Per-window preferences are not saved by Save Defaults , only Default Settings . NEdit performs poorly on very large files. Turn off Incremental Backup . With Incremental Backup on, NEdit periodically writes a full copy of the file to disk. Commands added to the Shell Commands menu (Unix only) don't output anything until they are finished executing. If the command output is directed to a dialog, or the input is from a selection, output is collected together and held until the command completes. De-select both of the options and the output will be shown incrementally as the command executes.","title":"Solutions to Common Problems"},{"location":"40/#known-defects","text":"Below is the list of known defects which affect NEdit-ng.","title":"Known Defects"},{"location":"40/#all-versions","text":"DEFECT Operations between rectangular selections on overlapping lines do nothing. Work Around None. These operations are very complicated and rarely used. DEFECT Cut and Paste menu items fail, or possibly crash, for very large (multi-megabyte) selections. Work Around Use selection copy (middle mouse button click) for transferring larger quantities of data. Cut and Paste save the copied text in server memory, which is usually limited.","title":"All Versions"},{"location":"40/#reporting-defects","text":"Submit bugs through the web at: https://github.com/eteran/nedit-ng/issues","title":"Reporting Defects"},{"location":"41/","text":"The Tabs dialog controls both the operation of Tab , and the interpretation of tab characters within a file. The first field, Tab Spacing , controls how NEdit-ng responds to tab characters in a file. On most Unix and VMS systems the conventional interpretation of a tab character is to advance the text position to the nearest multiple of eight characters (a tab spacing of 8). However, many programmers of C and other structured languages, when given the choice, prefer a tab spacing of 3 or 4 characters. Setting a three or four character hardware tab spacing is useful and convenient as long as your other software tools support it. Unfortunately, on Unix and VMS systems, system utilities, such as more, and printing software can't always properly display files with other than eight character tabs. Selecting Emulate Tabs will cause Tab to insert the correct number of spaces or tabs to reach the next tab stop, as if the tab spacing were set at the value in the Emulated tab spacing field. Backspace immediately after entering an emulated tab will delete it as a unit, but as soon as you move the cursor away from the spot, NEdit-ng will forget that the collection of spaces and tabs is a tab, and will treat it as separate characters. To enter a real tab character with Emulate Tabs turned on, use Ctrl + Tab . In generating emulated tabs, and in Shift Left , Paste Column , and some rectangular selection operations, NEdit-ng inserts blank characters (spaces or tabs) to preserve the alignment of non-blank characters. The Use tab characters in padding and emulated tabs option in the Tabs dialog instructs NEdit-ng whether to insert tab characters as padding in such situations. Turning this off, will keep NEdit-ng from automatically inserting tabs. Some software developers prefer to keep their source code free of tabs to avoid its misinterpretation on systems with different tab character conventions.","title":"Tabs Dialog"},{"location":"42/","text":"The Customize Window Title dialog allows you to customize and test the way information will be displayed in each window's title field. Definition of the title The upper half of the dialog can be used to select the various components that should be displayed in the title. The layout can be fine-tuned by editing the printf() like format string below the component buttons: additional characters can be entered, or the order can be changed. The following sequences are interpreted in the format string: %c ClearCase view tag (only relevant when NEdit-ng is used together with ClearCase) %[n]d directory, with one optional numeric digit n specifying the maximum number of trailing directory components to display. Skipped components are replaced by an ellipsis ( ... ). %f file name, without the path name. %h host name. %s NEdit-ng server name (server mode only). %[*]S file status, either verbose ( %S ) or brief ( %*S ). In verbose mode the file status is spelled out: read-only , locked or modified . In brief mode, abbreviations and an asterisk are used for the respective states: RO , LO , * . %u user name The format string and the component buttons are continously synchronized. The default format is: {{ '{%c}' }} [%s] %f (%S) - %d The resulting title will only contain elements with a value. Hence, the title is compressed as follows: Elements with no value are removed. Empty parenthesis pairs i.e. () , [] or {} , or parenthesis pairs containing only space(s), are removed. Sequences of spaces are replaced with one space. Leading spaces and dashes are removed. Trailing spaces and dashes are removed. If the server name and the ClearCase view tag are identical, only the first one specified in the format string will be displayed. Previewing the settings The lower part of the dialog can be used to test the selected title under various conditions. For some of the components that are selected for display, various states can be enforced on the preview. For instance, components that are not always active (such the NEdit-ng server name) can be turned on or off in the preview.","title":"Customize Window Title Dialog"},{"location":"42/#definition-of-the-title","text":"The upper half of the dialog can be used to select the various components that should be displayed in the title. The layout can be fine-tuned by editing the printf() like format string below the component buttons: additional characters can be entered, or the order can be changed. The following sequences are interpreted in the format string: %c ClearCase view tag (only relevant when NEdit-ng is used together with ClearCase) %[n]d directory, with one optional numeric digit n specifying the maximum number of trailing directory components to display. Skipped components are replaced by an ellipsis ( ... ). %f file name, without the path name. %h host name. %s NEdit-ng server name (server mode only). %[*]S file status, either verbose ( %S ) or brief ( %*S ). In verbose mode the file status is spelled out: read-only , locked or modified . In brief mode, abbreviations and an asterisk are used for the respective states: RO , LO , * . %u user name The format string and the component buttons are continously synchronized. The default format is: {{ '{%c}' }} [%s] %f (%S) - %d The resulting title will only contain elements with a value. Hence, the title is compressed as follows: Elements with no value are removed. Empty parenthesis pairs i.e. () , [] or {} , or parenthesis pairs containing only space(s), are removed. Sequences of spaces are replaced with one space. Leading spaces and dashes are removed. Trailing spaces and dashes are removed. If the server name and the ClearCase view tag are identical, only the first one specified in the format string will be displayed.","title":"Definition of the title"},{"location":"42/#previewing-the-settings","text":"The lower part of the dialog can be used to test the selected title under various conditions. For some of the components that are selected for display, various states can be enforced on the preview. For instance, components that are not always active (such the NEdit-ng server name) can be turned on or off in the preview.","title":"Previewing the settings"}]}